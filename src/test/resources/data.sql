CREATE TABLE public.list_study_questions (
                                             user_id bigint NOT NULL,
                                             question_id integer NOT NULL
);

CREATE TABLE public.lists_question_interview (
                                                 user_id bigint NOT NULL,
                                                 question_id integer NOT NULL
);

CREATE TABLE public.lists_testing_interview (
                                                user_id bigint NOT NULL,
                                                testing_id integer NOT NULL
);

CREATE SEQUENCE public.question_id_seq
    START WITH 432
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

CREATE TABLE public.question_interview (
                                           id integer DEFAULT nextval('public.question_id_seq'::regclass) NOT NULL,
                                           question character varying NOT NULL,
                                           answer character varying NOT NULL,
                                           topic character varying NOT NULL
);

CREATE SEQUENCE public.statistic_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

CREATE TABLE public.statistic (
                                  id bigint DEFAULT nextval('public.statistic_id_seq'::regclass) NOT NULL,
                                  date timestamp without time zone NOT NULL,
                                  result integer NOT NULL,
                                  user_id bigint,
                                  type character varying NOT NULL,
                                  know_answer integer NOT NULL
);

CREATE SEQUENCE public.testing_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

CREATE TABLE public.testing_interview (
                                          id integer DEFAULT nextval('public.testing_id_seq'::regclass) NOT NULL,
                                          question character varying NOT NULL,
                                          picture character varying,
                                          first_false_answer character varying,
                                          second_false_answer character varying,
                                          third_false_answer character varying,
                                          fourth_false_answer character varying,
                                          fifth_false_answer character varying,
                                          correct_answer character varying,
                                          answer character varying
);

CREATE SEQUENCE public.users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

CREATE TABLE public.users (
                              id bigint DEFAULT nextval('public.users_id_seq'::regclass) NOT NULL,
                              first_name character varying NOT NULL,
                              last_name character varying NOT NULL,
                              email character varying NOT NULL,
                              password character varying NOT NULL,
                              role character varying NOT NULL,
                              registration_date timestamp without time zone NOT NULL
);

INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 12) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 72) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 96) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 108) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 159) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 275) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 311) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 359) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (8, 336) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (4, 275) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (4, 159) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (4, 336) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 75) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 41) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 11) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 337) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 231) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 202) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 226) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 350) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 210) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 258) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 398) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 313) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (14, 306) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 12) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 96) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 95) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 109) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 124) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 126) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 176) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 139) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 151) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 432) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 364) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 215) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 339) ON CONFLICT DO NOTHING;
INSERT INTO public.list_study_questions (user_id, question_id) VALUES (17, 353) ON CONFLICT DO NOTHING;

INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 319) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 169) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 194) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 259) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 213) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 68) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 188) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 101) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 360) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 274) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 119) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 27) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 108) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 48) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (15, 252) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 298) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 391) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 226) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 286) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 347) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 390) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 328) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 330) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 187) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 235) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 204) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 108) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 142) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 282) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (7, 397) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 128) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 160) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 225) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 211) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 98) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 355) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 277) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 31) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 286) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 105) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 17) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 109) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 186) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 218) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (4, 366) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 137) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 201) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 162) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 56) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 263) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 364) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 396) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 15) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 19) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 159) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 367) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 83) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 151) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 216) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (16, 339) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 233) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 32) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 217) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 133) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 326) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 253) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 423) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 266) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 395) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 399) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 116) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 184) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 301) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (9, 46) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 415) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 210) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 182) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 128) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 352) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 229) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 39) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 30) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 190) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 397) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 341) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 147) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 85) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 374) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (10, 249) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 358) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 162) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 28) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 62) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 392) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 107) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 333) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 301) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 338) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 344) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 221) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 123) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 275) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 212) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (11, 147) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 168) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 73) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 7) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 192) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 242) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 126) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 190) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 71) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 247) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 104) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 61) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 201) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 47) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 365) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (12, 13) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 238) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 321) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 386) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 424) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 203) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 54) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 121) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 246) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 217) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 235) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 315) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 158) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 244) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 245) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (13, 21) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 295) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 49) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 288) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 33) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 419) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 420) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 200) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 298) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 92) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 240) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 179) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 219) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 157) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 351) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (18, 211) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 118) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 285) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 246) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 185) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 285) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 228) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 369) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 64) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 379) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 394) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 308) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 276) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 216) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 285) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 21) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 251) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 246) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 118) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 185) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (19, 23) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 258) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 9) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 353) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 94) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 357) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 369) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 382) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 103) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 200) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 364) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 403) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 398) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 307) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (20, 216) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 192) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 66) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 169) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 374) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 409) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 235) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 237) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 245) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 333) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 373) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 274) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 250) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (21, 383) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 353) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 290) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 98) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 35) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 100) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 230) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 403) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 136) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 189) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 10) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 375) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 138) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 431) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (2, 87) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 47) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 106) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 128) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 198) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 137) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 395) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 276) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 313) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 11) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 77) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 221) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 28) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 143) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 374) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (6, 184) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 422) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 75) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 32) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 415) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 21) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 288) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 263) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 314) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 234) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 62) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 91) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 318) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 235) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (5, 139) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 301) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 273) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 39) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 294) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 246) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 342) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 423) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 221) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 359) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 254) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 156) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 207) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 406) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 19) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_question_interview (user_id, question_id) VALUES (1, 250) ON CONFLICT DO NOTHING;

INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 32) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 36) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 4) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 3) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 18) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 10) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 6) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 24) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 14) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (19, 26) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 28) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 3) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 14) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 27) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 8) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 12) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 10) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 23) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 17) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 6) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 18) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 26) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (10, 36) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 4) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 33) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 10) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 16) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 32) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 3) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 17) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 8) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 18) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 21) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 11) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (11, 13) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 24) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 29) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 26) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 7) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 17) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 8) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 36) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 9) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (12, 14) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 17) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 33) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 19) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 15) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 35) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 5) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 18) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 26) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (13, 7) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 40) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 35) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 12) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 27) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 5) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 39) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 11) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 3) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 14) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 9) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 29) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (14, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 13) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 32) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 36) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 5) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 35) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 9) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 23) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 19) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 8) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 31) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 30) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (18, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 16) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 42) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 43) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 46) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 23) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 29) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 1) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 19) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 35) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 11) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (2, 30) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 42) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 40) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 7) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 23) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 14) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 31) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 25) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 48) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 20) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 41) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 37) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 22) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 30) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (6, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 24) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 4) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 9) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 2) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 38) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 41) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 34) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 39) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 18) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 12) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 27) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 31) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 52) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 25) ON CONFLICT DO NOTHING;
INSERT INTO public.lists_testing_interview (user_id, testing_id) VALUES (1, 49) ON CONFLICT DO NOTHING;

INSERT INTO public.question_interview (id, question, answer, topic) VALUES (1, 'Что такое ООП?', '<span class="selected_text color_selected_text">ООП</span> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. <br>Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - передать ему сообщение, в ответ на которое, объект может изменить собственное состояние. <span class="selected_text color_selected_text">Класс</span> — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а <span class="selected_text color_selected_text">объект</span> – экземпляр класса, созданный на основе этого описания.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (2, 'Какие преимущества у ООП?', '<span class="selected_text color_selected_text">Легко читается</span> - не нужно выискивать в коде функции и выяснять, за что они отвечают. <br><span class="selected_text color_selected_text">Быстро пишется</span> - можно быстро создать сущности, с которыми должна работать программа. <br><span class="selected_text color_selected_text">Простота реализации большого функционала</span> - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей. <br><span class="selected_text color_selected_text">Меньше повторений кода</span> - не нужно писать однотипные функции для разных сущностей.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (3, 'Какие недостатки у ООП?', 'Потребление памяти - объекты потребляют больше оперативной памяти, чем примитивные типы данных. <br>Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов. <br>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения). <br>Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом. <br>Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (4, 'Назовите основные принципы ООП', 'Абстракция <br>Инкапсуляция <br>Наследование <br>Полиморфизм', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (5, 'Что такое абстракция? <br>(С примером)', '<span class="selected_text color_selected_text">Абстракция</span> – означает выделение главных, наиболее значительных характеристик предмета и наоборот отбрасывание второстепенных, незначительных.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (6, 'Что такое инкапсуляция? <br>(С примером)', '<span class="selected_text color_selected_text">Инкапсуляция</span> - означает ограничение доступа к данным и возможностям их изменения. <br>Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (7, 'Что такое наследование? <br>(С примером)', '<span class="selected_text color_selected_text">Наследование</span> - это свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (8, 'Что такое полиморфизм? <br>(С примером)', '<span class="selected_text color_selected_text">Полиморфизм</span> – предоставляет возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса. <br>Есть три вида полиморфизма: <br> <span class="selected_text color_selected_text">-</span>ad hoc полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - переопределение метода. <br> <span class="selected_text color_selected_text">-</span>параметрический полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения). <br> <span class="selected_text color_selected_text">-</span>subtype полиморфизм - самый популярный - возможность объектов с одинаковой спецификацией(интерфейс \ класс \ abstract класс) иметь различную реализацию. <p>Пример: <br>Переопределение методов, интерфейсы.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (9, 'Что такое ассоциация?', 'Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование. <br><span class="selected_text color_selected_text">Ассоциация</span> - обозначает связь между объектами. Например, игрок играет в определенной команде. <p>Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать. <p><span class="selected_text color_selected_text">Является - "is a"</span> - подразумевает наследование. <br><span class="selected_text color_selected_text">Имеет - "has a"</span> - подразумевает ассоциацию (агрегацию или композицию).', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (10, 'Что такое композиция?', '<span class="selected_text color_selected_text">Композиция</span> — более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. <br>Например, в класс автомобиля содержит объект класса электрического двигателя: <p><img class="center" src="images/DBImageInterview/question/10.png" width="300" height="200" alt="image"/><p> При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (11, 'Что такое агрегация?', 'Агрегация является особой формой ассоциации. Это более конкретизированные отношения между объектами. <br><span class="selected_text color_selected_text">Агрегация</span> — отношение когда один объект является частью другого. <br>Например: Студент входит в Группу любителей физики. Это представляет отношения HAS-A. <p>Агрегация определяет отношение HAS A ("имеет"), но связь слабее, чем в композиции, т.к. объекты будут равноправны.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (12, 'Расскажите про раннее и позднее связывание.', 'Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен. <p>Раннее связывание - если метод известен компилятору,  то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для final, перегруженных, статических методов. <p>Позднее связывание (late binding) - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для переопределенных и абстрактных методов. <p>Вот пример: Object a = ... // какое-то присваивание a.toString(); <br>На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание. <p>В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект. <p>Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (13, 'Что такое SOLID?', '<span class="selected_text color_selected_text">SOLID</span> — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. <p><span class="selected_text color_selected_text">S (Single Responsibility Principle)</span> - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. <br>Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы. <p><span class="selected_text color_selected_text">O (Open Closed Principle)</span> - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. <br>Чтобы не сломать логику в классе-родителе, мы наследуемся от него и реализуем что-то своё, и используем свой класс. <p><span class="selected_text color_selected_text">L (Liskov’s Substitution Principle)</span> - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы. <p><span class="selected_text color_selected_text">I (Interface Segregation Principle)</span> - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий. <p><span class="selected_text color_selected_text">D (Dependency Inversion Principle)</span> - принцип инверсии зависимостей - зависимость на абстракциях. <br>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. <br>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Чтобы менять поведение классов. <p>Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) и разные карты оплаты.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (14, 'Какая основная идея языка?', '<span class="selected_text color_selected_text">«Написано однажды - работает везде».</span>  WORA (write once, run anywhere) <br>Идея основывается в написании одного кода, который будет работать на любой платформе.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (15, 'За счет чего обеспечивается кроссплатформенность?', 'Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. <br>Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС. <br>Байт код для JVM может исполняться везде где установлена JVM. <br>Код не нужно перекомпилировать под каждую из платформ.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (16, 'Какие преимущества у java?', 'Объектно-ориентированное программирование - структура данных становится объектом, которым можно управлять для создания отношений между различными объектами. <p>Язык высокого уровня с простым синтаксисом и плавной кривой обучения - синтаксис Java основан на C++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов. <p>Стандарт для корпоративных вычислительных систем - корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C. <p>Безопасность - благодаря отсутствию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице"). <p>Независимость от платформы - Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием. <p>Язык для распределенного программирования и комфортной удаленной совместной работы - Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках. <p>Автоматическое управление памятью - Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM). <p>Многопоточность (Поток — наименьшая единица обработки в программировании) Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью. <p>Стабильность и сообщество - Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (17, 'Какие недостатки у java?', 'Платное коммерческое использование (с 2019) <p>Низкая производительность из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти. <p>Не развитые инструменты по созданию GUI приложений на чистой java. <p>Многословный код <br>Java — это более легкая версия неприступного C++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (18, 'Что такое JDK? Что в него входит?', '<span class="selected_text color_selected_text">JDK (Java Development Kit)</span> - комплект разработчика приложений на языке Java, включает JRE и набор инструментов разработчика приложений на языке Java: <br>- компилятор Java (javac) <br>- стандартные библиотеки классов java <br>- примеры <br>- документацию <br>- различные утилиты', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (19, 'Что такое JRE? Что в него входит?', '<span class="selected_text color_selected_text">JRE (java Runtime Environment)</span> - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (20, 'Что такое JVM?', '<span class="selected_text color_selected_text">Байт-код Java</span> — набор инструкций, скомпилированный компилятором, исполняемый JVM.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (21, 'Что такое загрузчик классов (classloader)?', 'Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class <p>При запуске JVM, используются три загрузчика классов: <br>- Bootstrap ClassLoader - базовый загрузчик (загружает платформенные классы JDK из архива rt.jar) <p>- Extension ClassLoader - загрузчик расширений (загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext) <p>- System ClassLoader - системный загрузчик (загружает классы приложения, определенные в CLASSPATH) <p>ClassLoader выполняет три основных действия в строгом порядке: <br>1. загрузка байт-кода из ресурсов и создание экземпляра класса Class <br>сюда входит поиск запрошенного класса среди загруженных ранее, получение байт-кода для загрузки и проверка его корректности, создание экземпляра класса Class (для работы с ним в runtime), загрузка родительских классов. Если родительские классы и интерфейсы не были загружены, то и рассматриваемый класс считается не загруженным. <br>2.связывание (или линковка) <br>по спецификации этот этап разбивается еще на три стадии: <br>Проверка: происходит проверка корректности полученного байт-кода. <br>Подготовка:  выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (при этом явная инициализация, если она есть, происходит уже на этапе инициализации). <br>Разрешение: разрешение символьных ссылок типов, полей и методов. <br>3. инициализация полученного объекта  <br>вызывает код Java, который инициализирует переменные класса их правильными начальными значениями. <p>Все эти этапы выполняются последовательно со следующими требованиями: <br>Класс должен быть полностью загружен прежде, чем слинкован. <br>Класс должен быть полностью проверен и подготовлен прежде, чем проинициализирован. <br>Ошибки разрешения ссылок происходят во время выполнения программы, даже если были обнаружены на этапе линковки. <p>Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать. <p>ClassLoader выполняет три основных действия в строгом порядке: <br>•        Загрузка: находит и импортирует двоичные данные для типа. <br>•        Связывание: выполняет проверку, подготовку и (необязательно) разрешение. <br> -        Проверка: обеспечивает правильность импортируемого типа. <br> -        Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию. <br> -        Разрешение: преобразует символические ссылки из типа в прямые ссылки. <br>•        Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями. <p>Базовый загрузчик является нативным и его реализация включена в JVM. <br>java.lang.ClassNotFoundException.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (22, 'Что такое сборщик мусора?', '<br>(Garbage collector)	Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора: <br>Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. <br>Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. <br>Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. <br>Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. <p>Сборщик мусора выполняет две задачи: <br>- поиск мусора. <br>- очистка мусора. <p>Для обнаружения мусора есть два подхода: <br>1. Учет ссылок (Reference counting); <br>Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти. <br>2. Трассировка (Tracing). (используется в HotSpot); <br>Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты, которые доступны с живого объекта. Всё остальное - мусор. <br>От этих рутов проходим все дерево ссылок, и те до которых мы не добрались, то это мусор. Пример, метод main, локальные переменные, нативные ссылки, нативные ссылки, основной поток приложения (возможно и др.потоки, т.е. потоки вообще). <p>Процессы сборки мусора разделяются несколько видов: <br>minor GC (малая) - частый и быстрый, работает только с областью памяти "young generation"; <br>- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world); <br>- «живые» объекты из Eden перемещаются в область памяти «To»; <br>- «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»; <br>- Eden и «From» очищаются от мусора; <br>- «To» и «From» меняются местами; <br>- приложение возобновляет работу; <br>major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения. <br>В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти. <br>full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (214, 'Расскажите про быструю сортировку.', 'Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. <br>Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (103, 'Как создать собственное («пользовательское») исключение?', 'Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException) и переопределит методы.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (283, 'Что такое ORDER BY?', '<span class="selected_text color_selected_text">ORDER BY</span> упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание <span class="selected_text color_selected_text">ASC</span> или убывание <span class="selected_text color_selected_text">DESC</span> для каждого столбца. По умолчанию установлено - возрастание.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (45, 'Каким образом переменные передаются в методы, по значению или по ссылке?', 'В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». <br>С примитивами - это будет копия содержимого. <br>С ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (224, 'Что такое монитор? Как монитор реализован в java?', '<span class="selected_text color_selected_text">Монитор</span> - (средство обеспечения контроля за доступом к ресурсу) механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта. <br>Удобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения. <br>В Java монитор реализован с помощью ключевого слова synchronized.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (376, 'Расскажите про аннотацию @Inject', '@Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость: <p><img class="center" src="images/DBImageInterview/question/376.1.png" width="250" height="100" alt="image"/><p> <p>@Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named: <p><img class="center" src="images/DBImageInterview/question/376.2.png" width="500" height="75" alt="image"/><p>', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (26, 'Что такое char?', '16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (398, 'Что такое ViewResolver?', '<span class="selected_text color_selected_text">ViewResolver</span> - распознаватель представлений - это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером. <br>Spring Framework поставляется с большим количеством реализаций ViewResolver. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL. <br><span class="selected_text color_selected_text">InternalResourceViewResolver</span> — реализация ViewResolver по умолчанию, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени. <br>Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков. <br>Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (414, 'Какие преимущества и недостатки микросервисов.', '<span class="selected_text color_selected_text">Преимущества: </span> <br>-маленькие и простые сервисы с понятными API и понятными связями между сервисами VS огромный монолит, в котором непонятно как всё взаимодействует. <br>-проще тестировать. <br>-независимые релизы. <br>-независимая деградация, т.е. если какой-то сервис лежит, но он не взаимодействует с пользователями, то это не влияет на работу. <br>-независимое масштабирование. <br>-легче пробовать новые технологии, переписав один сервис, а не весь монолит. <br>-у сервиса есть команда-владелец, к которой можно обратиться за помощью. <br><span class="selected_text color_selected_text">Недостатки: </span> <br>-сложно отслеживать запросы, так как они проходят через множество сервисов, а в монолите всё в одном месте. Решаемо с помощью установки идентификатора каждому запросу и поиску по нему с помощью graylog. <br>-RPC сложнее вызова метода. <br>-сложности распределенных систем: отказы, таймауты, ретраи, дубли... <br>-сложнее запустить: выбор языка, упаковка, настройка процедуры выкладки, ротации и заливки логов, мониторинга и триггеров и другие.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (423, 'REST vs SOAP', '<span class="selected_text color_selected_text">SOAP</span> — это формат протокола обмена сообщениями, основанный на XML поверх HTTP. Нет ограничений на тип транспортного протокола. Можно и HTTP и MQ. <br>SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML. <br>В SOAP необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы. <br><span class="selected_text color_selected_text">REST</span> — это архитектурный подход. Можно обмениваться сообщениями на основе XML, JSON или любого другого формата. Использование транспортного протокола HTTP. <br>REST не имеет стандартного языка определения сервиса (популярны Swagger и Open API). <br>RESTFful веб-сервисы проще реализовать, так как используется JSON, который легче анализировать и обрабатывать. И REST не требует наличия определения службы для предоставления веб-службы. <p>Минус Rest при работе в highLoad: формат JSON довольно тяжелый и содержит в себе схему объекта, из-за чего увеличивается нагрузка на сеть + время на сериализацию и десериализацию. Но есть бинарные протоколы-аналоги. Например, Protocol Buffers, который отправляет чисто данные и не содержит в себе схему. Они могут быть в 20-100 раз быстрее.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (36, 'Почему String неизменяемый и финализированный класс?', '1. Для возможности реализации строкового пула (String pool) <br>Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку. <p>2. Безопасность <br>Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом. <p>3. Для многопоточности. Неизменяемые строки потокобезопасны <br>Так как строка неизменяемая то, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны. <p>4. Ключ для HashMap <br>Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (230, 'Что означает ключевое слово volatile?', '<br>Почему операции над volatile переменными не атомарны? Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения. <br>Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине. <br>Атомарная операция выглядит единой и неделимой командой процессора. <br>C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных. <br>Переменная volatile находится в хипе, а не в кэше стека. <p><span class="selected_text color_selected_text">Атомарная</span> - выполняется целиком, либо не выполняется вовсе.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (27, 'Сколько памяти занимает boolean?', 'Зависит от реализации JVM. В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (402, 'Что такое АОП? Как реализовано в спринге?', '<span class="title_color text-bold">Аспектно-ориентированное программирование (АОП)</span> — это парадигма программирования, целью которой является повышение модульности за счет разделения междисциплинарных задач. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода. АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению. <br><span class="selected_text color_selected_text">Аспект в АОП</span> - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом. <br><span class="selected_text color_selected_text">Совет (advice)</span> – дополнительная логика — код, который должен быть вызван из точки соединения. <br><span class="selected_text color_selected_text">Точка соединения (join point)</span> — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет. <br><span class="selected_text color_selected_text">Срез (pointcut)</span> — набор точек соединения. <br>Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики. <br>Есть два варианта создания прокси-класса: <br>1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; <br>2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (165, 'Как устроена HashMap, сложность основных операций? <br>(Расскажите про принцип корзин)?', '<img class="center" src="images/DBImageInterview/question/165.webp" width="500" height="250" alt="image"/><p> <span class="selected_text color_selected_text">HashMap</span> – внутри состоит из корзин и списка элементов, на которые ссылаются корзины. <br>Корзины – массив. <br>Элементы(Node) – связанный список, то есть каждый элемент списка имеет указатель на следующий элемент. <br>При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction() - может быть одинаковая у разных хэш-кодов, который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals. <br>Если оба равны: идет перезапись. <br>Если не равен equals: добавляется элемент в конец списка. <p>HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин. <br>Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов. <br>После удвоения все объекты будут перераспределены с учетом нового количества корзин. <p>HashMap не запоминает порядок добавления. Ключи элементов должны быть уникальными, может быть null. Значения элементов могут повторяться, могут быть null. Если ключ уже существует (даже при разных значениях), то будет замена объекта. <br>Сначала ключ проверяется на нал, если нал, то помещается в первую корзину, корзины состоят из Node. В него записывается значение хэш кода, ключ и значение, ссылка на следующий нод, если нет ссылки, но null. <br>После определенного количества объектов в корзинах, она с линкед лист заменяется на поиск по бинарному дереву.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (37, 'Почему строка является популярным ключом в HashMap в Java?', 'Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (38, 'Что делает метод intern() в классе String?', 'Помещает строку в pool строк.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (79, 'Для чего в Java используются статические блоки инициализации?', 'Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (34, 'Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?', 'Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый объект строки. <br>Рекомендуется использовать StringBuilder или StringBuffer.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (40, 'Какая основная разница между String, StringBuffer, StringBuilder?', '<span class="selected_text color_selected_text">String</span> - неизменяемый, потокобезопасный; <br><span class="selected_text color_selected_text">StringBuffer</span> - изменяемый, потокобезопасный; <br><span class="selected_text color_selected_text">StringBuilder</span> - изменяемый, потоконебезопасный.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (104, 'Расскажите про механизм обработки исключений в java (Try-catch-finally)', 'Try - блок в котором может появиться исключение; <br>Catch - блок в котором мы указываем исключение и логику его обработки; <br>Finally - блок который обязательно отработает;', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (411, 'Обмен сообщениями в микросервисах.', 'По существу, есть два варианта: синхронное взаимодействие или асинхронное взаимодействие. <br>Синхронное взаимодействие микросервисов обычно осуществляется через HTTP и REST-подобные сервисы, которые возвращают XML или JSON — хотя это не является обязательным (посмотрите, например, на Google Protocol Buffers). Используйте REST-коммуникацию, когда вам нужен немедленный ответ. <br>Асинхронная микросервисная связь обычно осуществляется посредством обмена сообщениями с помощью реализации JMS и/или с помощью протокола, такого как AMQP - это облегченный слой перед сервисами - брокерасообщений, используемый, например, в качестве балансировщика нагрузки или для реализации какого-либо вида аутентификации и/или авторизации. Например, Kafka или RebbitMQ. Обычно, на практике не следует недооценивать интеграцию по электронной почте / SMTP. Используйте асинхронное взаимодействие, когда вам не нужен немедленный ответ. <br>Брокеры сообщений (очереди сообщений) - это проверенный способ реализации коммуникации между субсервисами, что позволяет: <br>Асинхронная связь (без ожидания). <br>Может легко масштабировать различные службы (нет зависимостей JVM, может развертывать различные службы на разных серверах). <br>Может управлять событиями централизованно (просто еще один паб sub). <br>Масштабируемость (легко добавить другой сервис, который должен взаимодействовать с некоторыми существующими сервисами).', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (60, 'Могут ли нестатические методы перегрузить статические?', 'Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (41, 'Существуют ли в java многомерные массивы?', 'Многомерные массивы в их классическом понимании в java не существуют. <br>Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается многомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (43, 'Что такое сигнатура метода?', 'Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения. <br>А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (69, 'Может ли абстрактный класс в Java содержать метод main?', 'Да, абстрактный класс в Java может содержать метод main.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (70, 'Может ли быть абстрактный класс без абстрактных методов?', 'Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (44, 'Расскажите про метод main', 'Является, как правило, точкой входа в программу и вызывается JVM. <br>Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы. <br>static - чтобы JVM смогла загрузить его во время компиляции. <br>public static void и сигнатура - обязательное декларирование. <br>Мэйнов может быть много и может не быть вообще. <br>Также мэйн может быть перегружен.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (46, 'Какие виды классов есть в java?', '1. Вложенные классы – нестатические классы внутри внешнего класса. <br>2. Вложенные статические классы – статические классы внутри внешнего класса. <br>3. Локальные классы Java – классы внутри методов. <br>4. Анонимные Java классы – классы, которые создаются на ходу. <br>5. Final, abstract, enum - классы.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (49, 'Что такое «анонимные классы»? Где они применяются?', 'Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. <br>Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр. <p>Анонимные классы имеют несколько ограничений: <br>- Их использование разрешено только в одном месте программы - месте его создания; <br>- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться; <br>- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа. <p>Анонимные классы обычно применяются для: <br>- создания объекта функции (function object), например реализация интерфейса Comparator; <br>- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных; <br>- в статическом методе генерации; <br>- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс. <p>Анонимные классы всегда являются конечными классами. <br>Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования».', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (86, 'Зачем нужен equals(). Чем он отличается от операции ==?', 'equals() -  сравнение по состоянию <br>== -  по ссылкам', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (105, 'Возможно ли использование блока try-finally (без catch)?', 'try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (106, 'Может ли один блок catch отлавливать сразу несколько исключений?', 'Да', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (410, 'Случаи утечки памяти в Java.', 'ObjectInputStream и ObjectOutputStream хранят ссылки на все объекты, с которыми они работали, чтобы передавать их вместо копий. Для решения этой проблемы необходимо периодически вызывать метод reset(). <br>Каждый экземпляр класса Thread в Java выделяет память для своего стека (по умолчанию, это 512 Кб; изменяется с помощью параметра -Xss). Неоптимизированные приложения, использующие множество потоков, могут привести к необоснованно высокому потреблению памяти. <br>Нестатичный внутренний класс, который вы используете, хранит ссылку на внешний класс. Это приводит к хранению большого графа объектов. <br>Как только экземпляр-синглтон был инициализирован, он остаётся в памяти на всё время жизни приложения. <br>Статичная переменная хранится своим классом, а как следствие, его загрузчиком (classloader). По причине внешнего использования увеличивается шанс, что сборщик мусора не соберёт данный экземпляр.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (413, 'Какие различия между Repository и DAO?', 'Краткий список тезисов, характеризующих различия между Repository и DAO: <br>DAO инкапсулирует доступ к источнику данных. <br>DAO является реализацией слоя объектно-реляционного отображения. <br>DAO более ориентирован на источник данных. <br>Repository представляет более высокий уровень абстракции. <br>Repository выполняет роль коллекции объектов домена в памяти. <br>Repository ориентирован на модель предметной области.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (100, 'Можно ли обработать необрабатываемые исключения?', 'Можно, чтобы в некоторых случаях программа не прекратила работу.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (101, 'Какой оператор позволяет принудительно выбросить исключение?', 'Throw', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (53, 'Что такое конструктор по умолчанию?', 'Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию». <br>Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (54, 'Могут ли быть приватные конструкторы? Для чего они нужны?', 'Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса. <br>Нужен для реализации паттернов, например singleton.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (67, 'Могут ли у абстрактного класса в языке Java быть статические методы?', 'Да, абстрактные классы могут объявлять и определять статические методы.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (68, 'Что такое абстрактный метод?', 'Это метод без тела.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (246, 'Расскажите про util.Concurrent поверхностно.', 'Классы и интерфейсы пакета java.util.concurrent объеденины в несколько групп по функциональному признаку: <p><span class="title_color text-bold">collections</span> - Набор эффективно работающих в многопоточной среде коллекций. CopyOnWriteArrayList(Set), ConcurrentHashMap. <br>Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException. <br>Отличие ConcurrentHashMap связано с внутренней структурой хранения пар key-value. ConcurrentHashMap использует несколько сегментов, и данный класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет блокировать остальные 15. <p>CopyOnWriteArrayList: <br> - volatile массив внутри <br> - lock только при модификации списка, поэтому операции чтения очень быстрые <br> - новая копия массива при модификации <br> - fail-fast итератор <br> - модификация через iterator невозможна - UnsupportedOperationException <p><span class="selected_text color_selected_text">synchronizerd</span> - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser. <p><span class="selected_text color_selected_text">CountDownLatch</span> - объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты и они продолжат выполнение кода. Одноразовый. <br><span class="selected_text color_selected_text">CyclicBarrier</span> - барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. Отличие связано с тем, барьер можно использовать повторно(в цикле). <br><span class="selected_text color_selected_text">Exchanger</span> - объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange, сопровождаемый самоблокировкой потока. Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками. <br><span class="selected_text color_selected_text">Phaser</span> - объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным. <br><span class="selected_text color_selected_text">Atomic</span> - Набор атомарных классов для выполнения атомарных операций. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized. <br><span class="selected_text color_selected_text">Queues</span> - содержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений. Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью. <br><span class="selected_text color_selected_text">Locks</span> - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock. <br><span class="selected_text color_selected_text">Lock</span> - базовый интерфейс, предоставляющий более гибкий подход при ограничении доступа к ресурсам/блокам по сравнению с использованием synchronized. Так, при использовании нескольких блокировок, порядок их освобождения может быть произвольный. Имеется возможность перехода к альтернативному сценарию, если блокировка уже захвачена. <p><span class="selected_text color_selected_text">Condition</span> - интерфейсное условие в сочетании с блокировкой Lock позволяет заменить методы монитора/мьютекса (wait, notify и notifyAll) объектом, управляющим ожиданием событий. Объект с условием чаще всего получается из блокировок с использованием метода lock.newCondition(). Таким образом можно получить несколько комплектов wait/notify для одного объекта. Блокировка Lock заменяет использование synchronized, а Condition — объектные методы монитора. <p><span class="selected_text color_selected_text">ReadWriteLock</span> - интерфейс создания read/write блокировок, который реализует один единственный класс ReentrantReadWriteLock. Блокировку чтение-запись следует использовать при длительных и частых операциях чтения и редких операциях записи. Тогда при доступе к защищенному ресурсу используются разные методы блокировки, как показано ниже: <p><img class="center" src="images/DBImageInterview/question/246.png" width="350" height="65" alt="image"/> <p><span class="selected_text color_selected_text">Executors</span> - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable. <br>ExecutorService служит альтернативой классу Thread, предназначенному для управления потоками. В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод: <br>void execute(Runnable thread); <br>При вызове метода execute исполняется поток thread. <br><span class="selected_text color_selected_text">shutdown</span> - принудительно завершает работу потоков. <br><span class="selected_text color_selected_text">unwaitTermination</span> - работает, как join, в параметры передаем число и что это число значит (дней, секунд и прочее).', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (394, 'Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?', 'Существует 2 области видимости по умолчанию. <br><span class="selected_text color_selected_text">Singleton</span> - область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин. <br><span class="selected_text color_selected_text">Prototype</span> - приводит к созданию нового бина каждый раз, когда он запрашивается. <br>Для бинов со scope “prototype” Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте (контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов). <p>И 4 области видимости в веб-приложении. <br><span class="selected_text color_selected_text">Request</span> - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин <br><span class="selected_text color_selected_text">Session</span> - Область видимости — 1 сессия. На каждую сессию создается новый бин <br><span class="selected_text color_selected_text">Application</span> - Область видимости — жизненный цикл ServletContext <br><span class="selected_text color_selected_text">WebSocket</span> - Область видимости — жизненный цикл WebSocket <br>Жизненный цикл web csope полный. <p>В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket. <br>WebSocket обеспечивает двустороннюю связь между клиентом и сервером, используя одно TCP соединение.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (74, 'Может ли один интерфейс наследоваться от другого? От двух других?', 'Да, может. Используется ключевое слово extends.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (109, 'В каком порядке следует обрабатывать исключения в catch блоках?', 'От наследника к предку.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (63, 'Могут ли классы быть статическими?', 'Класс можно объявить статическим за исключением классов верхнего уровня. <br>Такие классы известны как «вложенные статические классы» (nested static class).', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (65, 'Что такое абстрактные классы? Чем они отличаются от обычных?', 'Абстрактным называется класс, на основе которого не могут создаваться объекты. <br>Как обычный класс, но с абстрактными методами. <br>Нельзя создать объект или экземпляр абстрактного класса. <br>Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. <br>Наследниками абстрактного класса могут быть другие абстрактные классы.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (66, 'Можно ли создать экземпляр абстрактного класса?', 'Нет, этого делать нельзя. Суть абстрактного класса заключается в том, что он не завершён, и его нужно завершить в классах-наследниках. То есть этот класс не готов к использованию. <br>В нём, например, может отсутствовать реализация каких-то методов. Раз класс не готов к использованию, то нельзя создавать его объект. А вот экземпляры наследников абстрактного класса создавать можно.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (197, 'Расскажите про класс Collectors и его методы.', 'Нужен для того, чтобы упаковывать стримы в коллекции: <br><span class="selected_text color_selected_text">toList()</span> - преобразует поток в список — List<T> <br><span class="selected_text color_selected_text">toSet()</span> - преобразует поток в список — Set<T> <br><span class="selected_text color_selected_text">toMap()</span> - преобразует поток в список — Map<K, V> <br>Используются в методе collect().', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (400, 'Расскажите про паттерн Front Controller, как он реализован в Spring?', '<span class="selected_text color_selected_text">Front controller</span> - обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком – DispatcherServlet с маппингом “/”. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller. <br>Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д. <br>❖  Один из контекстов будет корневым, а все остальные контексты будут дочерними. <br>❖  Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. <br>❖  Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. <br>WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у. <br>ContextLoaderListener создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (76, 'Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 'Класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать: <br>InterfaceB.super.method();', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (78, 'Зачем нужны и какие бывают блоки инициализации?', '<span class="selected_text color_selected_text">Инициализация</span> - это когда мы впервые задаем переменной какое-либо значение. <br>Существуют статические и нестатические блоки инициализации. <br>Используются для выполнения кода, который должен выполняться один раз при инициализации класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (82, 'Что такое класс Object?', 'Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы. <br>Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (98, 'Опишите иерархию исключений', '1. класс Throwable (checked) <p>2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие) <p>3. от Exception <br> - > RuntimeException (unchecked) <br> - > FileNotFoundException <br> - > IOException, SQLException, ReflectiveOperationException (checked) <p>4. RuntimeException (unchecked): <br>   ClassCastExceptiuon <br>   IndexOutOfBoundException <br>   AritthmeticException <br>   NullPointerException <p>checked - зависит от программиста, unchecked - от программиста не зависит.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (383, 'Расскажите про аннотацию @Profile', '<span class="selected_text color_selected_text">Профили</span> - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod. <br>Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны. <br>Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional. <br>Ее можно ставить на @Configuration и Component классы.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (88, 'Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?', 'Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (90, 'Для чего нужен метод hashCode()?', 'Вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (92, 'Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?', 'Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (93, 'Могут ли у разных объектов быть одинаковые hashCode()?', 'Когда у разных объектов одинаковые хеш-коды называется — коллизией.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (96, 'Чем a.getClass().equals(A.class) отличается от a instanceOf A.class?', 'getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (89, 'Какой контракт между hashCode() и equals()?', '1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны. <br>2) Если equals объектов true, то и хэшкоды должны быть равны. <br>3) Переопределив equals, всегда переопределять и hashcode.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (99, 'Расскажите про обрабатываемые и необрабатываемые исключения.', '1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными. <br>2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception. <br>Checked исключения отличаются от Unchecked исключения в Java, тем что наличие\\обработка Checked исключения проверяются компилятором на этапе компиляции. <br>Unchecked наличие\\обработка исключения происходит на этапе выполнения.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (102, 'О чем говорит ключевое слово throws?', 'Метод потенциально может выбросить исключение с указанным типом. <br>Передаёт обработку исключения вышестоящему методу.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (336, 'JMS и MOM.', 'JMS, Java Message Service - это Java API для работы с Message-Oriented Middleware(MOM), предоставляющий разработчикам возможность создавать гибкие и слабосвязанные приложения с использованием асинхронного обмена данными между приложениями (клиентами/серверами) через посредника. Асинхронность - это главная причина создания и использования JMS. <br>MOM, Message-Oriented Middleware (промежуточное программное обеспечение) - подпрограммное обеспечение промежуточного слоя, ориентированное на обмен сообщениями в распределённом окружении. Прежде всего предназначено для реализации отложенного обмена сообщениями, на основе которого и строится Messaging System.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (111, 'Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?', 'finally-секция может «перебить» throw/return при помощи другого throw/return', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (114, 'Для чего нужна сериализация?', 'Для компактного сохранения состояния объекта и считывание этого состояния.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (120, 'Когда стоит изменять значение поля serialVersionUID?', 'Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями. Например при удалении какого-либо его атрибута когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (178, 'Для чего нужна аннотация @FunctionalInterface?', 'Нужна чтобы точно определить интерфейс как функциональный. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (183, 'Почему Stream называют ленивым?', 'Методы не будут выполняться пока не будет вызван терминальный метод.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (95, 'Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?', 'Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию. <br>Более равномерное распределение по таблице, уменьшаются случаи коллизии.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (97, 'Что такое исключения?', '<span class="selected_text color_selected_text">Исключение</span> — это ошибка (является объектом), возникающая во время выполнения программы. <br><span class="selected_text color_selected_text">Ошибка</span> - то, что нельзя исправить, о чем можно только сообщить. <br><span class="selected_text color_selected_text">Исключения</span> - просто исключительные ситуации.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (108, 'Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?', 'Может и оно будет передано в виртуальную машину Java (JVM). <br>Для случая с методом main произойдет две вещи: <p>- будет завершен главный поток приложения; <br> будет вызван ThreadGroup.uncaughtException.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (110, 'Что такое механизм try-with-resources?', 'Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока. <br>В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable. (AutoCloseable родитель Closeable). Closeable существует для обратной совместимости.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (113, 'Что такое сериализация и как она реализована в Java?', 'Сериализация это процесс сохранения состояния объекта в последовательность байт; <br>Реализована через интерфейс - маркер Serializable.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (115, 'Опишите процесс сериализации/десериализации с использованием Serializable.', '1) Класс объекта должен реализовывать интерфейс Serializable. <br>2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream. <br>3) Записать в поток: oos.writeObject(Object). <br>4) Сделать oos.flush() и oos.close().', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (116, 'Как изменить стандартное поведение сериализации/десериализации?', 'Использовать интерфейс Externalizable. <p>Переопределить методы <br> writeExternal(ObjectOutput out) throws IOException <br> readExternal(ObjectInput in) throws IOException, ClassNotFoundException', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (118, 'Как создать собственный протокол сериализации?', 'Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal(). <p>В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (397, 'Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?', '<span class="selected_text color_selected_text">@Controller</span> - специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping. <br>@RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов. <p><span class="selected_text color_selected_text">@ResponseBody</span> - сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse. <p>ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody. <br>Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном. <br>return ResponseEntity.status(213);', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (147, 'Чем LinkedHashSet отличается от HashSet?', 'Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет. В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (408, 'Какие принципы clean code?', '<span class="selected_text color_selected_text">1. SOLID</span> — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. <br>S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. <br>O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. <br>L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы. <br>I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий. <br>D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. <br>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. <br>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. <br>Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) и разные карты оплаты. <br><span class="selected_text color_selected_text">2. YAGNI</span> <br>You Aren’t Gonna Need It / Вам это не понадобится. <br>Если пишете код, то будьте уверены, что он вам понадобится. <br><span class="selected_text color_selected_text">3. DRY</span> <br>Don’t Repeat Yourself / Не повторяйтесь <br>Этот принцип заключается в том, что нужно избегать повторений одного и того же кода. Лучше использовать универсальные свойства и функции. <br><span class="selected_text color_selected_text">4. KISS</span> <br>Keep It Simple, Stupid – не усложняй! <br>Смысл этого принципа программирования заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед. <br><span class="selected_text color_selected_text">5. Бритва Оккама</span> <br>Не создавайте ненужных сущностей без необходимости.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (124, 'Какой способ клонирования предпочтительней?', 'Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования: <br>Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone()); <br>Поля для клонирования указываются явно; <br>Возможность клонировать даже final поля.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (125, 'Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?', 'Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); <br>Он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (132, 'Что такое «коллекция»?', '<span class="selected_text color_selected_text">Коллекция</span> – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (137, 'Расскажите про метод sorted().', 'sorted() - возвращает отсортированный поток.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (138, 'Расскажите про метод distinct().', 'distinct() - возвращает поток равнозначный исходному, но без дубликатов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (206, 'Как создать Base64 кодировщик и декодировщик?', 'Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (166, 'Что такое LinkedHashMap?', 'Упорядоченная реализация хэш-таблицы.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (284, 'Что такое DISTINCT?', '<span class="selected_text color_selected_text">DISTINCT</span> указывает, что для вычислений используются только уникальные значения столбца.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (134, 'Почему Map — это не Collection, в то время как List и Set являются Collection?', 'Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса). <br>Map -это совокупность пар "ключ" - "значение". <br>У map нет итерабл, не понятно почему проводить итерацию.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (140, 'Чем различаются Enumeration и Iterator?', 'Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекомендуется юзать Iteratorb<p>Оба интерфейса предназначены для обхода коллекции, но есть различия: <br> - с помощью Enumeration нельзя добавлять/удалять элементы; <br> - в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д); <br> - Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях. <p>Iterator имеет 3 метода: hasNext(), next(), remove().', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (141, 'Как между собой связаны Iterable, Iterator и «for-each»?', 'Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator. <br>Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (195, 'Расскажите про метод collect() в Stream.', 'Stream.collect() является одним из терминальных методов. Это позволяет выполнять изменяемые операции свертывания (переупаковка элементов в некоторые структуры данных и применение некоторой дополнительной логики, объединение их и т.д.) <br>Преобразует стрим в коллекцию.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (145, 'Расскажите про реализации интерфейса Set.', 'В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки. <br>В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева. <br>LinkedHashSet хранит элементы в порядке добавления.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (146, 'В чем отличия TreeSet и HashSet?', 'HashSet быстрее, чем TreeSet. <br>В HashSet элементы в случайном порядке, в TreeSet в отсортированном. <br>HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add(), remove() и contains(), по сравнению с временем log(n), предлагаемым TreeSet.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (159, 'Что такое Deque? Чем отличается от Queue?', 'Deque- двухсторонняя очередь, расширяет queue. Он отличается от Queue тем, что можно добавлять и удалять элементы как в хвосте так и в голове. Количество методов удваивается. <br>Пример: <br>addFirst(E e); <br>addLast(E e); <br>Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. <br>Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), а используются методы класса Object, основанные на сравнении ссылок. <br>Рекомендуется использовать вместо устаревшего Stack. <br>ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (180, 'Что такое ссылка на метод?', 'Ссылка на статический метод - ContainingClass::staticMethodName <p>Ссылка на нестатический метод конкретного объекта - containingObject::instanceMethodName <p>Ссылка на конструктор - ClassName::new <p>Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (299, 'Что такое хранимые процедуры? Для чего они нужны?', '<span class="selected_text color_selected_text">Хранимая процедура</span> — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные методы языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения. <br>Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее. <p>Иными словами, хранимые процедуры – это своего рода программы внутри базы данных, которые хранят реализованный нами алгоритм, и в случае запуска этих программ выполняют этот алгоритм.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (359, 'Для чего нужна аннотация Transient?', '<span class="selected_text color_selected_text">@Transient</span> используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных. <br>Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля. <br>Transient fields (временные поля): <br>❖   static и final поля сущностей. <br>❖   иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (152, 'Оцените количество памяти на хранение одного примитива типа byte в ArrayList?', 'ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (181, 'Что такое лямбда-выражение? Чем его можно заменить?', 'Лямбда-выражение - упрощённая запись анонимного класса, реализующего функциональный интерфейс.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (156, 'Почему LinkedList реализует List и Deque?', 'LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса Deque.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (160, 'Приведите пример реализации Deque.', 'Linked list, Stack, ArrayDeque.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (161, 'Какая коллекция реализует FIFO?', 'Queue', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (162, 'Какая коллекция реализует LIFO?', 'Vector, ArrayDeque', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (164, 'Какие существуют реализации Map?', 'TreeMap, HashMap, HashTable (устаревший, синхронизированный, работает как хэшмап, ключ и значение не могут быть null), LinkedHashMap. <p>Если нужна работа с многопоточностью лучше использовать не хэштабл, а конкурентхэшмап.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (285, 'Что такое GROUP BY?', '<span class="selected_text color_selected_text">GROUP BY</span> используется для агрегации записей результата по заданным атрибутам. <br>Cоздает отдельную группу для всех возможных значений (включая значение NULL) <br>При использовании GROUP BY все значения NULL считаются равными.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (171, 'Возможна ли ситуация, когда HashMap выводится в список даже с ключами имеющими разные hashCode()?', 'Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (217, 'Расскажите про красно-черное дерево.', 'Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям: <br>1) Узел либо красный, либо черный. <br>2) Корень - черный. <br>3) Все листья - черные и не хранят данных. <br>4) Оба потомка каждого красного узла - черные. <br>5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов. (это называется черная высота) Если не одинаковое, то происходит переворот. <br>При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения. <br>При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности. <br>В этом и состоит преимущество. <br>Сложность поиска, вставки и удаления - O(log(n))', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (242, 'Что такое Фреймворк fork/join? Для чего он нужен?', 'Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно. <br>Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной (простой) и решаемой последовательным способом. <br>Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи. <br>Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно. <br>Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач. <br>Ещё одно преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (249, 'Что такое «потокобезопасность»?', '<span class="selected_text color_selected_text">Потокобезопасность</span> – свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (168, 'Что такое WeakHashMap?', 'WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (169, 'Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?', 'По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (170, 'Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?', 'Объект скорее всего добавится, но обратно мы не сможем получить его.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (172, 'Почему нельзя использовать byte[] в качестве ключа в HashMap?', 'Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (173, 'Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?', 'Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (174, 'Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?', 'O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (175, 'Какое худшее время работы метода get(key) для ключа, который есть в HashMap?', 'O(N) - линейное', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (422, 'Какие 6 принципов REST API?', 'Client-Server. Отделяя пользовательский интерфейс от хранилища данных, мы улучшаем переносимость пользовательского интерфейса на другие платформы и улучшаем масштабируемость серверных компонент за счёт их упрощения. <br>Stateless (без состояния). Каждый запрос от клиента к серверу должен содержать в себе всю необходимую информацию и не может полагаться на какое-либо состояние, хранящееся на стороне сервера. Таким образом, информация о текущей сессии должна целиком храниться у клиента. <br>Cacheable (кэшируемость). Это ограничение требует, чтобы для данных в ответе на запрос явно было указано - можно их кэшировать или нет. Если ответ поддерживает кэширование, то клиент имеет право повторно использовать данные в последующих эквивалентных запросов без обращения на сервер. <br>Uniform interface (единообразие интерфейса). Если применить к систем инженерный принцип общности/единообразия, то архитектура всего приложения станет проще, а взаимодействие станет прозрачнее и понятнее. Для выполнения этого принципа необходимо придерживаться нескольких архитектурных ограничений.  <br>REST накладывает на интерфейс четыре ограничения: <br> 1) идентичность ресурсов; <br> 2) манипуляция над ресурсами через представление; <br> 3) исчерпывающие, понятные человеку сообщения; <br> 4) гипермедиа (hypermedia) как движок для состояния приложения (HATEOAS) - ссылки на другие ресурсы внутри приложения. <br>Layered system (многоуровневая система). Многоуровневость достигается за счёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют. <br>Code on demand (код по мере необходимости, не обязательно). REST позволяет наращивать функциональность клиентского приложения по мере необходимости при помощи скачивания и исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, уменьшая количество заранее написанных возможностей.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (185, 'Как из коллекции создать стрим?', '<img class="center" src="images/DBImageInterview/question/185.png" width="400" height="45" alt="image"/>', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (193, 'Расскажите про метод skip() в Stream.', 'skip(n) - возвращает новый поток, пропуская первые n элементов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (188, 'Расскажите про метод map() в Stream.', 'Метод map() заданным образом преобразует каждый элемент стрима, потом преобразует все объекты в итоговый стрим.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (192, 'Расскажите про метод limit() в Stream.', 'limit(n) - возвращает новый поток, ограниченный n-результатами.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (186, 'Какие промежуточные методы в стримах вы знаете?', 'filter(boolean - Predicate) <br>map() <br>flatMap() <br>limit(n) <br>skip(n) <br>concat(Stream s1, Stream s2) <br>peek(someFunction) <br>distinct() <br>sorted()', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (190, 'Чем отличаются методы map() и flatMap() в Stream?', 'map для каждого объекта в стриме возвращает по 1 объекту, потом преобразует все объекты в итоговый стрим. <br>flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (191, 'Расскажите про метод filter() в Stream.', 'Фильтрует стрим, возвращая только те элементы, что проходят по условию (Predicate). <br>Проверяет значение на “true” и “false”.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (196, 'Расскажите про метод reduce() в Stream.', 'Позволяет выполнять агрегатные функции и возвращать один результат. <p>Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (198, 'Расскажите о параллельной обработке в Java 8.', 'Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный. <br>Работает на фреймворке fork/join.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (199, 'Что такое IntStream и DoubleStream?', 'В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : IntStream, LongStream, DoubleStream. Работает быстрее, чем стрим с классами-обертками. <br>Поддерживают дополнительные терминальный методы sum(), average(), mapToObj().', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (201, 'Какие новые классы для работы с датами появились в java 8?', 'LocalDate <br>LocalTime <br>LocalDateTime <br>ZonedDateTime <br>Period <br>Duration', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (418, 'Расскажите про TDD, DDD, BDD.', '<span class="selected_text color_selected_text">TDD — Test Driven Development</span> - методология разработки ПО, которая основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест. <br><span class="selected_text color_selected_text">BDD — Behaviour Driven Development</span> - предполагает описание тестировщиком или аналитиком пользовательских сценариев на естественном языке вида "я как пользователь хочу когда нажали кнопку пуск тогда показывалось меню как на картинке". <br><span class="selected_text color_selected_text">DDD — Domain Driven Design</span> - это набор принципов и схем, направленных на создание оптимальных систем объектов. Процесс разработки сводится к созданию программных абстракций, которые называются моделями предметных областей.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (202, 'Расскажите про класс Optional', '<span class="selected_text color_selected_text">Optional</span> - новый класс в пакете java.util, является контейнером (оберткой) для значений которая также может безопасно содержать null. Благодаря опциональным типам можно забыть про проверки на null и NullPointerException.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (204, 'Что такое jjs?', 'Инструмент командной строки для выполнения JavaScript-кодов на консоли.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (208, 'Что такое LocalDateTime?', 'LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (215, 'Расскажите про сортировку слиянием.', 'Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому асимптотика O(n*log(n)).', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (209, 'Что такое ZonedDateTime?', 'java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону (в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (203, 'Что такое Nashorn?', 'В Java 8, Nashorn, представлен значительно улучшенный движок javascript для замены существующего Rhino. Nashorn обеспечивает в 2-10 раз лучшую производительность, так как он напрямую компилирует код в памяти и передает байт-код в JVM. Nashorn использует функцию динамического вызова, представленную в Java 7, для повышения производительности. <br>* Nashorn — немецкое слово (Носорог).', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (205, 'Какой класс появился в Java 8 для кодирования/декодирования данных?', 'public static class Base64.Encoder <br>public static class Base64.Decoder', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (256, 'Почему Singleton считается антипаттерном?', '- Нельзя тестировать с помощью mock, но можно использовать powerMock. <br> - Нарушает принцип единой ответственности. <br> - Нарушает Open/Close принцип, его нельзя расширить.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (426, 'Расскажите про Code first vs Design first.', '<span class="selected_text color_selected_text">Code First</span> — сначала код, потом всё остальное. Сначала у нас считается логика, запускаются функции и нажимаются кнопочки, а уже потом придумывается интерфейс. <br><span class="selected_text color_selected_text">Design First</span> — сначала проектирование, потом всё остальное. Проектировщики сначала придумывают, как продукт должен выглядеть со стороны и работать, а потом уже программисты придумывают, как это оживить.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (339, 'Отличие HTTP vs HTTPS.', 'По HTTP информация передаётся в обычном виде, а по HTTPS — в зашифрованном.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (220, 'Сравните сложность вставки, удаления, поиска и доступа по индексу в ArrayList и LinkedList.', '<img class="center" src="images/DBImageInterview/question/220.png" width="600" height="300" alt="image"/>', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (219, 'Расскажите про очередь и стек.', '<span class="selected_text color_selected_text">Stack</span> - это область хранения данных, находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок-фрейм, который содержит локальные переменные метода и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO. <br><span class="selected_text color_selected_text">Queue</span> - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. <br>Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента. <br>Deque (Double Ended Queue) расширяет Queue и согласно документации это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. <br>Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (225, 'Что такое синхронизация? Какие способы синхронизации существуют в java?', '<span class="selected_text color_selected_text">Синхронизация</span> - это процесс, который позволяет выполнять потоки параллельно. <br>В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. <p>Способы синхронизации в Java: <br>Системная синхронизация с использованием wait()/notify(). <br>Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы! <br>Системная синхронизация с использованием join(). <br>Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу. <br>Использование классов из пакета java.util.concurrent.Locks - механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (327, 'Как мапятся даты (до java 8 и после)?', 'Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать. Были в пакете java.util. <br>Пример: @Temporal(TemporalType.DATE) <br>В Java 8 и далее аннотацию ставить не нужно. В пакете java.time напрямую сопоставляются с соответствующими типами SQL', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (395, 'Расскажите про аннотацию @ComponentScan', 'Первый шаг для описания конфигурации Spring это добавление аннотаций — @Component или наследников. <br>Однако, Spring должен знать где искать их. В @ComponentScan вы указываете пакеты, которые должны сканироваться. Можно указать массив строк. <br>Spring будет искать бины и в их подпакетах. <br>Мы можем расширить это поведение с помощью includeFilters и excludeFilters параметров в аннотации. <br>Для ComponentScan.Filter доступно пять типов фильтров: <br><span class="selected_text color_selected_text">ANNOTATION</span> - включает или исключает классы в сканах компонентов, помеченных заданными аннотациями <br><span class="selected_text color_selected_text">ASSIGNABLE_TYPE</span> - фильтрует все классы во время сканирования компонентов, которые либо расширяют класс, либо реализуют интерфейс указанного типа <br><span class="selected_text color_selected_text">ASPECTJ</span> - Когда мы хотим использовать выражения для выбора сложного подмножества классов <br><span class="selected_text color_selected_text">REGEX</span> - проверяет, соответствует ли имя класса заданному шаблону регулярного выражения. FilterType.REGEX проверяет как простые, так и полные имена классов <br><span class="selected_text color_selected_text">CUSTOM</span> - Если ни один из приведенных выше типов фильтров не соответствует нашим требованиям, мы также можем создать собственный тип фильтра <br>Нужно для того, что например, имея какой-то ненужный класс в не нашей библиотеке, мы можем создать для него фильтр, чтобы его бин не инициализировался.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (222, 'Что такое Многопоточность?', '<span class="selected_text color_selected_text">Multithreading</span> - это принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (406, 'Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.', 'Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы. <br>Ключевые особенности и преимущества Spring Boot: <br>1.       Простота управления зависимостями (spring-boot-starter-* в pom.xml). <br>Чтобы ускорить процесс управления зависимостями Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику в виде так называемых starter-пакетов. <br>Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей, библиотек и решения вопросов, связанных с конфликтом версий различных библиотек. <br>Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa. <br>Starter-пакеты можно создавать и свои. <br>2.        Автоматическая конфигурация. <br>Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration. (входит в состав аннотации @SpringBootApplication) <br>После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.yaml и т.п. Например, если добавим springboot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource и т.д. <br>Автоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять. <br>3.        Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty). <br>Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера. <br>4.        Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация. <br>5.        Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot. <br>6.        Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций. <br>Как происходит автоконфигурация в Spring Boot? <br>1.        Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение. <br>2.        @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики. <br>3.        Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения. <br>4.        Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет. <br>5.        Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container. <br>6.        Servlet container запускается, приложение готово к работе', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (232, 'Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?', 'Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Основной поток приложения может завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания, что поток-демон еще работает. <br>Поток демон можно сделать только если он еще не запущен. Пример демона - GC.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (237, 'Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().', 'Как остановить поток? <br>На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки). <br>Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется. <p>Схема действия при этом получается следующей: <br>Реализовать поток. <br>В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted(). <br>Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне. <br>Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение. <br>Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO. <br>Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile). <br>Почему не рекомендуется использовать метод Thread.stop()? <br>При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы? <br>В чем разница между interrupted() и isInterrupted()? <br>Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным. <br>Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается. <br>Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (258, 'Расскажите про паттерн Строитель (Builder).', 'Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта. <br>Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями. <br>Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации. <br>Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их. <p><span class="selected_text color_selected_text">+</span> : Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики. <br><span class="selected_text color_selected_text">-</span> : Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (330, 'Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?', 'Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (331, 'Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?', 'Нисколько - hasNext() осуществляет только проверку наличия следующего элемента.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (239, 'Что такое FutureTask?', 'FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (234, 'Как работает Thread.join()? Для чего он нужен?', 'Когда поток вызывает join(), он будет ждать пока поток, к которому он присоединяется, будет завершён, либо отработает переданное время: <br>void join() <br>void join(long millis) - с временем ожидания <br>void join(long millis, int nanos) <br>Применение: при распараллеливании вычисления, вам надо дождаться результатов, чтобы собрать их в кучу и продолжить выполнение.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (235, 'Чем отличаются методы wait() и sleep()?', 'метод <span class="selected_text color_selected_text">sleep()</span> - приостанавливает поток на указанное время. Состояние меняется на WAITING, по истечению - RUNNABLE. <br>метод <span class="selected_text color_selected_text">wait()</span> - меняет состояние потока на WAITING. Может быть вызван только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (236, 'Можно ли вызвать start() для одного потока дважды?', 'Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение. <br>Выдает: IllegalThreadStateException.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (250, 'Конкуренция и параллелизм.', '<span class="selected_text color_selected_text">Конкуренция</span> — это способ одновременного решения множества задач. <br><span class="selected_text color_selected_text">Параллелизм</span> — это способ выполнения разных частей одной задачи.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (267, 'Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).', 'Поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. <br>Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы. <br>Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (243, 'Что означает ключевое слово synchronized? Где и для чего может использоваться?', 'Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (244, 'Что является монитором у статического synchronized-метода?', 'Объект типа Class, соответствующий классу, в котором определен метод.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (245, 'Что является монитором у нестатического synchronized-метода?', 'Объект this.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (333, 'Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?', 'Может, если на данный столбец не наложено ограничение NOT NULL.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (296, 'Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?', 'Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (248, 'Java Memory Model', 'Описывает как потоки должны взаимодействовать через общую память. Определяет набор действий межпоточного взаимодействия. В частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока. <br>JMM определяет отношение между этими действиями "happens-before" - абстракцией обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X. <p>Можно выделить несколько основных областей, имеющих отношение к модели памяти: <br>Видимость (visibility). Один поток может временно сохранить значения некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память. <br>К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final. <br>С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в heap памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями. <br>synchronized - При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше». <br>volatile - запись volatile-переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение. <p>final - после того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. <br>Рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано. <br>Переупорядочивание (Reordering). Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее. Эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. <br>Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (257, 'Можно ли Singleton синхронизировать без synchronized у метода?', '- Можно сделать его Enum (eager). Это статический final класс с константами. JVM загружает final и static классы на этапе компиляции, а значит несколько потоков не могут создать несколько инстансов. <br>- C помощью double checked locking (lazy). Synchronized внутри метода. <p><img class="center" src="images/DBImageInterview/question/257.png" width="500" height="350" alt="image"/> <br>Для многопоточки, должны быть волотайл. <br>Все экземпляры enum-а являются singleton-ом.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (292, 'Что такое ограничения (constraints)? Какие вы знаете?', '<span class="selected_text color_selected_text">Ограничения</span> - это ключевые слова, которые помогают установить правила размещения данных в базе. Используются при создании БД. <p><span class="selected_text color_selected_text">NOT NULL</span> указывает, что значение не может быть пустым. <br><span class="selected_text color_selected_text">UNIQUE</span> обеспечивает отсутствие дубликатов. <br><span class="selected_text color_selected_text">PRIMARY KEY</span> - комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением. <br><span class="selected_text color_selected_text">CHECK</span> проверяет вписывается ли значение в заданный диапазон ( s_id int CHECK(s_id > 0) ) <br><span class="selected_text color_selected_text">FOREIGN KEY</span> создает связь между двумя таблицами и защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. <br><span class="selected_text color_selected_text">DEFAULT</span> устанавливает значение по умолчанию, если значения не предоставлено (name VARCHAR(20) DEFAULT &#39noname&#39).', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (332, 'Какие отличия между PRIMARY и UNIQUE?', 'По умолчанию PRIMARY создает кластерный индекс на столбце, а UNIQUE - не кластерный. PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись. <br>Таблица может иметь один PRIMARY KEY и много UNIQUE.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (348, 'Как влияет операция refresh на Entity объекты каждого из четырех статусов?', 'managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов. <br>new, removed, detached → exception.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (349, 'Как влияет операция detach на Entity объекты каждого из четырех статусов?', 'managed, removed → detached. <br>new, detached → операция игнорируется.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (265, 'Расскажите про паттерн Итератор (Iterator).', 'Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления. <br>Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс. <p>Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (266, 'Расскажите про паттерн Шаблонный метод (Template Method).', 'Поведенческий паттерн проектирования, который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом. <br>Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном классе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (271, 'Расскажите про паттерн Saga.', '<span class="selected_text color_selected_text">Сага</span> — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций. <p>Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно. <p>Типов транзакций в саге четыре: <br><span class="selected_text color_selected_text">Компенсирующая</span> — отменяет изменение, сделанное локальной транзакцией. <br><span class="selected_text color_selected_text">Компенсируемая</span> — это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей. <br><span class="selected_text color_selected_text">Поворотная</span> — транзакция, определяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца. <br><span class="selected_text color_selected_text">Повторяемая</span> — идет после поворотной и гарантированно завершается успехом.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (297, 'Когда полное сканирование набора данных выгоднее доступа по индексу?', 'Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором. <br>Таким образом, полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (281, 'Что такое суррогатные ключи?', '<span class="selected_text color_selected_text">Суррога́тный ключ</span> — это дополнительное служебное поле, автоматически добавленное к уже имеющимся информационным полям таблицы, предназначение которого — служить первичным ключом.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (286, 'Что такое LIMIT?', 'Ограничивает выборку заданным числом.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (279, 'Что лучше использовать join или подзапросы? Почему?', 'Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы. <br>Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (291, 'В чем разница между COUNT(*) и COUNT({column})?', '<span class="selected_text color_selected_text">COUNT(*)</span> подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами. <br><span class="selected_text color_selected_text">COUNT({column})</span> подсчитывает количество значений в {column}. При подсчете количества значений столбца эта форма функции COUNT не принимает во внимание значение NULL.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (293, 'Дайте определение терминам «простой», «составной» (composite), «потенциальный» (candidate) и «альтернативный» (alternate) ключ.', '<span class="selected_text color_selected_text">Простой ключ (Primary Key)</span> - это уникальное поле или комбинация полей в таблице, которые идентифицируют каждую запись (строку) в таблице. Он гарантирует уникальность значений и обеспечивает быстрый доступ к данным. <p><span class="selected_text color_selected_text">Составной ключ (Composite Key)</span> - это ключ, который состоит из двух или более полей в таблице и используется для идентификации записей. В отличие от простого ключа, составной ключ использует комбинацию полей для создания уникального идентификатора. <p><span class="selected_text color_selected_text">Потенциальный ключ (Candidate Key)</span> - это поле или комбинация полей в таблице, которые могли бы быть использованы в качестве простого ключа (Primary Key), но выбор конкретного ключа из потенциальных ключей делается на усмотрение разработчика. Все потенциальные ключи должны быть уникальными. <p><span class="selected_text color_selected_text">Альтернативный ключ (Alternate Key)</span> - это поле или комбинация полей в таблице, которые могут служить в качестве уникального идентификатора записей, но не выбраны разработчиком в качестве простого ключа (Primary Key). Альтернативные ключи могут использоваться для выполнения поисковых или сортировочных операций.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (375, 'Расскажите про аннотацию @Resource', '@Resource(аннотация java) пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. <p>@Resource //По умолчанию поиск бина с именем "context" <br>   private ApplicationContext context; <p>@Resource(name="greetingService") //Поиск бина с именем "greetingService" <p><img class="center" src="images/DBImageInterview/question/375.png" width="400" height="75" alt="image"/><p> <p>Разница с @Autowired: <br>❖   ищет бин сначала по имени, а потом по типу; <br>❖   не нужна дополнительная аннотация для указания имени конкретного бина; <br>❖   @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false); <br>❖   при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (312, 'Что такое ORM?', '<span class="selected_text color_selected_text">ORM(Object Relational Mapping)</span> - это концепция преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (314, 'Что такое Hibernate?', '<span class="selected_text color_selected_text">Hibernate</span> - библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (228, 'В каких состояниях может находиться поток?', '<span class="selected_text color_selected_text">New</span> - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется. <br><span class="selected_text color_selected_text">Runnable</span> - поток готов к выполнению, но планировщик еще не выбрал его. <br><span class="selected_text color_selected_text">Running</span> – поток выполняется. <br><span class="selected_text color_selected_text">Waiting/blocked/sleeping</span> - поток блокирован или поток ждет окончания работы другого потока. <br><span class="selected_text color_selected_text">Dead</span> - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока. <p><img class="center" src="images/DBImageInterview/question/228.png" width="850" height="200" alt="image"/>', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (295, 'Как создать индекс в SQL?', 'Индекс можно создать либо с помощью выражения CREATE INDEX: <br><img class="center" src="images/DBImageInterview/question/295.png" width="380" height="25" alt="image"/> <br>либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (298, 'Чем TRUNCATE отличается от DELETE?', '<span class="selected_text color_selected_text">DELETE</span> - оператор DML, удаляет записи из таблицы, которые удовлетворяют условиям WHERE. Медленнее, чем TRUNCATE. Есть возможность восстановить данные. <br><span class="selected_text color_selected_text">TRUNCATE</span> - DDL оператор, удаляет все строки из таблицы. Нет возможность восстановить данные - сделать ROLLBACK.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (379, 'Расскажите про аннотации @Primary и @Qualifier', '@Qualifier применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора: <p><img class="center" src="images/DBImageInterview/question/379.1.png" width="600" height="250" alt="image"/><p> <p>Соответственно, у одной из реализации GreetingService должна быть установлена соответствующая аннотация @Qualifier: <p><img class="center" src="images/DBImageInterview/question/379.2.png" width="450" height="125" alt="image"/><p> <br>@Primary тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен. <br>Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (310, 'Какие механизмы оптимизации запросов в БД?', 'Например, добавить индекс по нужной колонке.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (261, 'Расскажите про паттерн Прототип (Prototype).', 'Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации. <br>Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. <br><span class="selected_text color_selected_text">+</span> : Позволяет клонировать объекты, не привязываясь к их конкретным классам. <br><span class="selected_text color_selected_text">-</span> : Сложно клонировать составные объекты, имеющие ссылки на другие объекты.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (177, 'Что такое функциональный интерфейс?', 'Это интерфейс, который содержит только 1 абстрактный метод. <br>Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (268, 'Какие паттерны используются в Spring Framework?', '<span class="selected_text color_selected_text">Singleton</span> - Bean scopes <br><span class="selected_text color_selected_text">Factory</span> - Bean Factory classes <br><span class="selected_text color_selected_text">Prototype</span> - Bean scopes <br><span class="selected_text color_selected_text">Adapter</span> - Spring Web and Spring MVC <br><span class="selected_text color_selected_text">Proxy</span> - Spring Aspect Oriented Programming support <br><span class="selected_text color_selected_text">Template Method</span> - JdbcTemplate, HibernateTemplate etc <br><span class="selected_text color_selected_text">Front Controller</span> - Spring MVC DispatcherServlet <br><span class="selected_text color_selected_text">DAO</span> - Spring Data Access Object support <br><span class="selected_text color_selected_text">Dependency Injection</span> <p><span class="title_color text-bold">Dependency Injection (внедрение зависимости)</span> - это набор паттернов и принципов разработки программного обеспечения, которые позволяют писать слабосвязный код. <p><span class="title_color text-bold">ДАО</span> - объект для доступа к данным, структурный паттерн.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (305, 'Что такое TIMESTAMP?', '<span class="selected_text color_selected_text">DATETIME</span> предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт. <br><span class="selected_text color_selected_text">TIMESTAMP</span> хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. Тогда была создана Unix. При получении из базы отображается с учётом часового пояса. Размер: 4 байта.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (307, 'EXPLAIN в SQL', 'Когда вы выполняете какой-нибудь запрос, оптимизатор запросов MySQL пытается придумать оптимальный план выполнения этого запроса. Можно посмотреть этот план используя запрос с ключевым словом EXPLAIN перед оператором SELECT. <br>EXPLAIN SELECT * FROM categories <br>После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS. <br>EXPLAIN EXTENDED SELECT City.Name FROM City <br>Затем <br>SHOW WARNINGS', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (308, 'Как сделать запрос из двух баз?', 'Если в запросе таблица указывается с именем базы данных database1.table1, то таблица выбирается из database1, если просто table1, то - из активной базы данных. <br>Надо, чтобы базы были на одном сервере. <br><img class="center" src="images/DBImageInterview/question/308.png" width="400" height="60" alt="image"/>', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (309, 'Что быстрее убирает дубликаты distinct или group by?', 'Если нужны уникальные значения - DISTINCT. <br>Если нужно группировать значения - GROUP BY. <p>Если задача заключается именно в поиске дубликатов - GROUP BY будет лучше.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (344, 'Разница между PERSIST и MERGE?', 'persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException). <p>Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (318, 'Может ли абстрактный класс быть Entity?', 'Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (319, 'Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?', 'Может', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (320, 'Может ли Entity класс наследоваться от других Entity классов?', 'Может', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (321, 'Может ли не Entity класс наследоваться от Entity класса?', 'Может', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (429, 'Компиляция и запуск программы из командной строки.', 'javac className.class - чтобы скомпилировать из класса файл .java с байт-кодом <br>java className - чтобы запустить файл <br>Чтобы передать аргументы с main-метод, нужно просто перечислить их через пробел: <br>java className arg0 arg1 arg2', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (323, 'Для чего нужны аннотации @Embedded и @Embeddable?', '<span class="selected_text color_selected_text">@Embeddable</span> - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы. <br><span class="selected_text color_selected_text">@Embedded</span> - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (269, 'Какие паттерны используются в Hibernate?', '<span class="selected_text color_selected_text">Domain Model</span> – объектная модель предметной области, включающая в себя как поведение так и данные. <br><span class="selected_text color_selected_text">Data Mapper</span> – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя. <br><span class="selected_text color_selected_text">Proxy</span>  — применяется для ленивой загрузки. <br><span class="selected_text color_selected_text">Factory</span> — используется в SessionFactory.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (324, 'Что такое Mapped Superclass?', '<span class="selected_text color_selected_text">Mapped Superclass</span> - это класс, от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле. <br>Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (329, 'Как влияет операция persist на Entity объекты каждого из четырех статусов?', 'new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций. <br>managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений. <br>detached → exception сразу или на этапе commit-а транзакции. <br>removed → managed, но только в рамках одной транзакции.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (340, 'Как влияет операция remove на Entity объекты каждого из четырех статусов?', 'new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed. <br>managed → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов). <br>detached → exception сразу или на этапе commit-а транзакции. <br>removed → операция игнорируется.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (133, 'Расскажите про иерархию коллекций.', '<img class="center" src="images/DBImageInterview/question/133.png" width="600" height="400" alt="image"/>', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (276, 'Что такое DCL? Какие операции в него входят? Рассказать про них.', 'Операторы определения доступа к данным (Data Control Language, DCL): <br><span class="selected_text color_selected_text">GRANT</span> предоставляет пользователю (группе) разрешения на определенные операции с объектом. <br><span class="selected_text color_selected_text">REVOKE</span> отзывает ранее выданные разрешения. <br><span class="selected_text color_selected_text">DENY</span> задает запрет, имеющий приоритет над разрешением.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (337, 'CAP теорема.', 'В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств: <br><span class="selected_text color_selected_text">C (consistency)</span> — согласованность. Каждое чтение даст вам самую последнюю запись. <br><span class="selected_text color_selected_text">A (availability)</span> — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись). <br><span class="selected_text color_selected_text">P (partition tolerance)</span> — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (342, 'Что такое владелец связи?', 'В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения. <br>По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой. <br>В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (345, 'Какие два типа fetch стратегии в JPA вы знаете?', '1) <span class="selected_text color_selected_text">LAZY</span> — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля. <br>2) <span class="selected_text color_selected_text">EAGER</span> — данные поля будут загружены немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (347, 'Как влияет операция merge на Entity объекты каждого из четырех статусов?', 'new → будет создан новый managed entity, в который будут скопированы данные прошлого объекта. <br>managed → операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed. <br>detached → либо данные будут скопированы в существующий managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные. <br>removed → exception сразу или на этапе commit-а транзакции.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (338, 'Виды Statement.', 'Statement предназначен для выполнения простых SQL-запросов без параметров; <br>PreparedStatement используется для выполнения SQL-запросов с/без входных параметров; Добавляет методы управления входными параметрами. Защищает от sql-инъекций. <br>CallableStatement используется для вызовов хранимых процедур; Добавляет методы для манипуляции выходными параметрами.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (353, 'Для чего нужна аннотация @Cacheable?', '<span class="selected_text color_selected_text">@Cacheable</span> - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache: <p><span class="selected_text color_selected_text">❖ ENABLE_SELECTIVE:</span> только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня. <br><span class="selected_text color_selected_text">❖ DISABLE_SELECTIVE:</span> все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые. <br><span class="selected_text color_selected_text">❖ ALL:</span> сущности всегда кэшируются, даже если они помечены как некэшируемые. <br><span class="selected_text color_selected_text">❖ NONE:</span> ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня. <br><span class="selected_text color_selected_text">❖ UNSPECIFIED:</span> применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED. <p>Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (355, 'Как смапить составной ключ?', 'Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы. <p>@IdClass <br>Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями. <p>Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id. <p><img class="center" src="images/DBImageInterview/question/355.1.png" width="450" height="300" alt="image"/><img class="center" src="images/DBImageInterview/question/355.2.png" width="300" height="200" alt="image"/><p> <p>@EmbeddedId <br>Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable. <br>Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId. <p><img class="center" src="images/DBImageInterview/question/355.3.png" width="400" height="300" alt="image"/> <img class="center" src="images/DBImageInterview/question/355.4.png" width="350" height="150" alt="image"/>', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (360, 'Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?', 'В порядке от самого ненадежного и быстрого, до самого надежного и медленного: <br><span class="selected_text color_selected_text">1.        NONE</span> — без блокировки. <br><span class="selected_text color_selected_text">2.        OPTIMISTIC (синоним READ в JPA 1)</span> — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException. <br><span class="selected_text color_selected_text">3.        OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1)</span> — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение). <br><span class="selected_text color_selected_text">4.        PESSIMISTIC_READ</span> — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException. <br><span class="selected_text color_selected_text">5.        PESSIMISTIC_WRITE</span> — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки. <br><span class="selected_text color_selected_text">6.        PESSIMISTIC_FORCE_INCREMENT</span> — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась. <p>Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии: <p><img class="center" src="images/DBImageInterview/question/360.1.png" width="170" height="45" alt="image"/><p>Поле, аннотирование @Version, может быть целочисленным или временным. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности. <br>Позволяет отказать от блокировок на уровне БД и делать всё с JPA. <br>Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности. <br>Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки: <p><img class="center" src="images/DBImageInterview/question/360.2.png" width="500" height="50" alt="image"/>', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (361, 'Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?', '1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции; <br>2. second-level cache (кэш второго уровня) — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня. <br>3. Кэш запросов. <br>Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы. <br>В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти требованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются. <br>Особенности кэша первого уровня: <br>❖        включен по умолчанию, его нельзя отключить; <br>❖        связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий; <br>❖        при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются; <br>❖        при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией; <br>❖        если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет; <br>❖        сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных; <br>❖        метод clear() очищает весь кэш сессии. <p>В Hibernate предусмотрен кэш для запросов и он интегрирован с кэшем второго уровня. Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами. <br>PersistenceContext - это кэш первого уровня, в котором все объекты извлекаются из базы данных или сохраняются в базе данных. PersistenceContext отслеживает любые изменения, внесенные в управляемый объект. Если что-то меняется во время транзакции, то объект помечается как грязный. Когда транзакция завершается, эти изменения сбрасываются в постоянное хранилище. <p>Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными. <br>Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей. <p>Кэш второго уровня привязан к EntityManagerFactory.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (362, 'Как работать с кешем 2 уровня?', 'Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. <br>Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. <br>В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache. Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. <br>Что нужно сделать: <br>❖ добавить мавен-зависимость кэш-провайдера нужной версии. <br>❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory. <br>❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа на чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. <p>Стратегии параллельного доступа к объектам Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта. <br><span class="selected_text color_selected_text">❖ READ_ONLY:</span> Используется только для сущностей, которые никогда не изменяются (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются. <br><span class="selected_text color_selected_text">❖ NONSTRICT_READ_WRITE:</span> Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные. <br><span class="selected_text color_selected_text">❖ READ_WRITE:</span> Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. Ehcache использует эту стратегию по умолчанию. <br><span class="selected_text color_selected_text">❖ TRANSACTIONAL:</span> полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (370, 'Расскажите про аннотацию @Bean', 'Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый IoC-контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). <br>Имеет следующие свойства: <br>destroyMethod, initMethod — варианты переопределения методов инициализации и удаления бина, указав их имена в аннотации. <br>name — имя бина. По умолчанию именем бина является имя метода. <br>value — алиас для name().', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (368, 'Что такое IoC контейнер?', 'В среде Spring IoC-контейнер представлен интерфейсом ApplicationContext, который является оберткой над BeanFactory, предоставляющей дополнительные возможности, например AOP и транзакции. Интерфейс BeanFactory предоставляет фабрику для бинов, которая в то же время и является IoC-контейнером приложения. Управление бинами основано на конфигурации(аннотации или xml). Контейнер создает объекты на основе конфигураций и управляет их жизненным циклом от создания объекта до уничтожения.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (32, 'Какие нюансы у строк в Java?', '<span class="selected_text color_selected_text">Класс String в Java</span> -  неизменяемый из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (57, 'Какие модификаторы доступа есть в Java? Какие применимы к классам?', '<span class="selected_text color_selected_text">Private</span> – доступ к компоненту только из этого класса, в котором объявлен. <br><span class="selected_text color_selected_text">Default</span> – Переменная или метод будут доступны для любого другого класса в том же пакете. <br><span class="selected_text color_selected_text">Protected</span> – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета. <br><span class="selected_text color_selected_text">Public</span> – доступ к компоненту из экземпляра любого класса и любого пакета. Класс может быть объявлен с модификатором public и default.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (417, 'Расскажите про git cherry-pick.', 'Команда git cherry-pick используется для перенесения отдельных коммитов из одного места репозитория в другое, обычно между ветками разработки и обслуживания. Этот механизм отличается от привычных команд git merge и git rebase, которые переносят коммиты целыми цепочками.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (415, 'Что такое Remote procedure call (RPC)?.', 'Вызов удалённых процедур — класс технологий, позволяющих программам вызывать процедуры в другом адресном пространстве.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (23, 'Какие виды ссылок в Java?', '1) <span class="selected_text color_selected_text">StrongReference</span> — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа. <br>StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder. <p>2) <span class="selected_text color_selected_text">SoftReference</span> —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы. <br>StringBuilder builder = new StringBuilder(); <br>SoftReference<StringBuilder> softBuilder = new SoftReference(builder); <p>softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null. <br>softBuilder.clear() — удалит ссылку на объект StringBuilder. <br>То же самое работает для WeakReference. <p>3) <span class="title_color text-bold">WeakReference</span> — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезли strong-ссылки), то он удалит его из памяти. <p>4) <span class="title_color text-bold">PhantomReference</span> — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC. <br>Особенностей у этого типа ссылок две. <br>Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue. <br>Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue после того как выполниться метод finalize(). <p>So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared. <br>ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (262, 'Расскажите про паттерн Адаптер (Adapter).', 'Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. <br>Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. <br>При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. <p> <span class="selected_text color_selected_text">+</span> : Отделяет и скрывает от клиента подробности преобразования различных интерфейсов. <br> <span class="selected_text color_selected_text">-</span> : Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (366, 'Что такое Entity Grpah?', 'Граф сущностей может использоваться в качестве выборки или графика загрузки. Если используется график выборки, только атрибуты, указанные в графе сущностей, будут обрабатываться как FetchType.EAGER. Все остальные атрибуты будут ленивыми. Если используется график загрузки, все атрибуты, которые не указаны в графе объектов, сохранят свой тип выборки по умолчанию. <br>провайдер JPA загружает весь граф в один запрос выбора, а затем избегает получения ассоциации с другими запросами SELECT. Это считается хорошим подходом для повышения производительности приложений.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (371, 'Расскажите про аннотацию @Component', '<span class="selected_text color_selected_text">@Component</span> - используется для указания класса в качестве компонента spring. Такой класс будет сконфигурирован как spring Bean.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (377, 'Расскажите про аннотацию @Lookup', 'Обычно бины в приложении Spring является синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер. <br>Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (378, 'Можно ли вставить бин в статическое поле? Почему?', 'Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен. Чтобы исправить это, создайте нестатический сеттер-метод с @Autowired: <p><img class="center" src="images/DBImageInterview/question/378.png" width="500" height="125" alt="image"/><p>', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (380, 'Как заинжектить примитив?', 'Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом. <br>Такие значения можно получать из property файлов, из бинов, и т.п. <p><img class="center" src="images/DBImageInterview/question/380.png" width="280" height="50" alt="image"/><p> <p>В эту переменную будет внедрена строка, например из property или из view. <br>Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language). <p>Язык выражений Spring(SpEL) является мощным языком выражений, который поддерживает запросы и динамическую манипуляцию графа объекта.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (381, 'Как заинжектить коллекцию?', 'Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина. <br>Используя аннотацию @Qualifier можно настроить тип искомого бина. <br>Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс @Ordered.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (382, 'Расскажите про аннотацию @Conditional', 'Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean. <br>Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions. <br>Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют. <br>Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще не существует, с их BeanDefinition-ами можно. <br>Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями: <br>@Conditional(HibernateCondition.class, OurConditionClass.class) <br>Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (390, 'Расскажите про закрытие контекста.', 'Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. <br>Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (391, 'Расскажите про аннотацию @PostConstruct', 'Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessorов. <br>Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы. Он также может быть статическим, но преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина, и в таком случае смысл его использования для настройки бина пропадает. <br>Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (33, 'Что такое пул строк?', 'Область памяти где хранятся объекты строк. <br>При создании в пуле идет поиск строки: <br> - <span class="selected_text color_selected_text">если НЕ находит</span> -  создается строка, возвращается ссылка. <br> - <span class="selected_text color_selected_text">если находит</span> - возвращает ссылку найденной строки. <p>При этом использование оператора <span class="selected_text color_selected_text">new</span> заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк. <p>Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (289, 'Что делает оператор MERGE? Какие у него есть ограничения?', '<span class="selected_text color_selected_text">MERGE</span> позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя. <p>MERGE Ships AS t  -- таблица, которая будет меняться <br>USING (SELECT запрос ) AS s ON (t.name = s.ship)  -- условие слияния <br> THEN UPDATE SET t.launched = s.year -- обновление <br>WHEN NOT MATCHED -- если условие не выполняется <br> THEN INSERT VALUES(s.ship, s.year) -- вставка', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (387, 'Расскажите про создание экземпляров бинов.', 'Сначала BeanFactory из коллекции Map с объектами BeanDefinition достаёт те из них, из которых создаёт все BeanPostProcessor-ы (Инфраструктурные бины), необходимые для настройки обычных бинов. <br>Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition. <br>Созданием экземпляров бинов занимается BeanFactory на основе ранее созданных BeanDefinition. Из Map<BeanName, BeanDefinition> получаем Map<BeanName, Bean>. <br>Создание бинов может делегироваться кастомным FactoryBean. <p><img class="center" src="images/DBImageInterview/question/387.png" width="600" height="400" alt="image"/>', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (388, 'Расскажите про настройку созданных бинов.', 'На данном этапе бины уже созданы, мы можем лишь их донастроить. <br>Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как “post-processors” для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource. <br>Интерфейс несет в себе два метода: postProcessBeforeInitialization(Object bean, String beanName) и postProcessAfterInitialization(Object bean, String beanName). У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, второй - после. <br>Как правило, BeanPostProcessor-ы, которые заполняют бины через маркерные интерфейсы или тому подобное, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName), тогда как BeanPostProcessor-ы, которые оборачивают бины в прокси, обычно реализуют postProcessAfterInitialization (Object bean, String beanName). <br>Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены. <p>Есть два варианта создания этого класса: <br>1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; <br>2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy). <br>По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси. <p>Хронология событий: <br>1. Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов. <br>2. Затем, при наличии, будет вызван метод, аннотированный @PostConstruct. <br>3. Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший. <br>4. При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean. <br>5. В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh(). <br>6. Но даже после этого мы можем донастроить наши бины ApplicationListener-ами. <br>7. Теперь всё.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (430, 'Статусы ответа HTTP.', '1xx: Informational (информационные): <br>2xx: Success (успешно): <br>3xx: Redirection (перенаправление): <br>4xx: Client Error (ошибка клиента): <br>5xx: Server Error (ошибка сервера):', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (412, 'Преимущества очередей.', 'Основные преимущества использования очередей сообщений: <br>– Асинхронное общение между компонентами с гарантированной доставкой сообщений даже в случае недоступности обработчика сообщений. <br>– Позволяют горизонтально масштабировать приложения; распределяют процессы обработки информации; позволяют балансировать нагрузку. <br>– Дают возможность выдерживать пиковые нагрузки. <br>– Отказоустойчивость, хранит сообщения пока не истечет таймаут, или пока сообщение не будет обработано потребителем.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (392, 'Расскажите про аннотацию @PreDestroy', 'Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения. <br>Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими. Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных. <br>Класс, имплементирующий BeanPostProcessor, обязательно должен быть бином, поэтому мы его помечаем аннотацией @Component. <br>SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста. <br>SCOPE_PROTOTYPE — инициализация будет выполняться каждый раз по запросу. Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (396, 'Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.', 'Коротко: Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее: <br>- proxy, который создал Spring, создаёт persistence context (или соединение с базой). <br>- открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal). <br>- по мере надобности всё сохранённое достаётся и внедряется в бины. <p>Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции. <p>Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional? <br>Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода. <p>Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional? <br>Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода. <p>Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода? <br>Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить. <br>Значения атрибута propagation у аннотации: <br>REQUIRED — применяется по умолчанию. При входе в @Transactional метод будет использована уже существующая транзакция или создана новая транзакция, если никакой ещё нет. <br>REQUIRES_NEW — новая транзакция всегда создаётся при входе метод, ранее созданные транзакции приостанавливаются до момента возврата из метода. <br>NESTED — корректно работает только с базами данных, которые умеют savepoints. При входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. Если текущей транзакции не существует, будет создана новая. <br>MANDATORY — всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет. <br>SUPPORTS — метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без транзакции, если её нет. <br>NOT_SUPPORTED — при входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться без транзакции. <br>NEVER — явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, будет выброшено исключение. <br>Остальные атрибуты: <br>rollbackFor = Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException. <br>noRollbackFor = Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции. <br>rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде. <br>readOnly - разрешает только операции чтения. <br>В свойстве transactionManager хранится ссылка на менеджер транзакций, определенный в конфигурации Spring. <br>timeOut - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций. <br>isolation - уровень изолированности транзакций. <p>Подробно: <br>Для работы с транзакциями Spring Framework использует AOP-прокси: <br>Для включения возможности управления транзакциями нужно разместить аннотацию @EnableTransactionManagement у класса конфигурации @Configuration. <br>Она означает, что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси. Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию. <br>Пропагейшн работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то используется this и вызов проходит мимо прокси. Это ограничение можно обойти при помощи self-injection. <br>Слой логики(Service) - лучшее место для @Transactional. <br>Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например, метода save() произойдет примерно следующее: <br>1. Вначале мы имеем: <br>❖  Класс TransactionInterceptor, у которого вызывается метод invoke(...), внутри которого вызывается метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит магия транзакций. <br>❖  TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию. <br>❖  EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю EntityManager и  делегировать выполнение  конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler. <br>2. Transaction  Interceptor <br>В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция. TransactionInterceptor сам не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager. Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после: <br>     try { <br>        transaction.begin();         // логика до <br>        service.save(); <br>        transaction.commit();      // логика после <br>      } catch(Exception ex) { <br>       transaction.rollback(); <br>       throw ex; <br>      } <br>3. TransactionManager <br>Менеджер транзакций должен предоставить ответ на два вопроса: <br>❖  Должен ли создаться новый EntityManager? <br>❖  Должна ли стартовать новая транзакция БД? <br>Решение принимается, основываясь на следующих фактах: <br>❖  Выполняется ли хоть одна транзакция в текущий момент или нет; <br>❖  Атрибута «propagation» в @Transactional. <br>Если TransactionManager решил создать новую транзакцию, тогда: <br>❖  Создается новый EntityManager; <br>❖  EntityManager «привязывается» к текущему потоку (Thread); <br>❖  «Получается» соединение из пула соединений БД; <br>❖  Соединение «привязывается» к текущему потоку. <br>И EntityManager и это соединение привязываются к текущему потоку, используя  переменные ThreadLocal. <br>4. EntityManager proxy <br>Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager, записанного в поле класса DAO. Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist(). <br>5. Отрабатывает DAO-метод save(). <br>6. TransactionInterceptor <br>Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции. <p>Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса. <br>Вся работа происходит через прокси-объекты разных классов. Представим, что у нас в классе сервиса только один метод с аннотацией @Transactional, а остальные нет. Если мы вызовем метод с @Transactional, из которого вызовем метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику. Однако, если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (399, 'Чем отличаются Model, ModelMap и ModelAndView?', '<span class="selected_text color_selected_text">Model</span> - интерфейс, представляет коллекцию пар ключ-значение Map<String, Object>. <br>Содержимое модели используется для отображения данных во View. <br>Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей. <br>Объекты-значения из модели также могут содержать бизнес-логику. <br><span class="selected_text color_selected_text">ModelMap</span> - класс, наследуется от LinkedHashMap, тоже используется для передачи значений для визуализации представления. <br>Преимущество ModelMap заключается в том, что он дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map. <br><span class="selected_text color_selected_text">ModelAndView</span> - это просто контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно. <br>View используется для отображения данных приложения пользователю. <br>Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п. <br>Интерфейс View преобразует объекты в обычные сервлеты.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (401, 'Расскажите про паттерн MVC, как он реализован в Spring?', '<span class="selected_text color_selected_text">MVC</span> — это шаблон проектирования, делящий программу на 3 вида компонентов: <br><span class="selected_text color_selected_text">Model</span> — модель отвечает за хранение данных. <br><span class="selected_text color_selected_text">View</span> — отвечает за вывод данных на фронтенде. <br><span class="selected_text color_selected_text">Controller</span> — оперирует моделями и отвечает за обмен данными model с view. <br>Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (view). <br><span class="selected_text color_selected_text">Spring MVC</span> - это веб-фреймворк, основанный на Servlet API, с использованием двух шаблонов проектирования - Front controller и MVC. <br>Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбиты между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов. <br>Основные интерфейсы для обработки запросов: <br>DispatcherServlet является главным контроллером, который получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext. <br>HandlerMapping. Выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния. <br>Controller — оперирует моделями и отвечает за обмен данными model с view. <br>ViewResolver. Выбор, какое именно View должно быть показано клиенту на основе имени, полученного от контроллера. <br>View. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои. <br>HandlerAdapter. Помогает DispatcherServlet вызвать и выполнить метод для обработки входящего запроса. <br>ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг. <p>Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу: <p><img class="center" src="images/DBImageInterview/question/401.jpg" width="600" height="400" alt="image"/><p>❖  После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера. <br>❖   Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла). <br>❖   При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера. <br> ➢    если это REST-запрос на сырые данные (JSON/XML), то DispatcherServlet сам его отправляет, минуя ViewResolver; <br> ➢    если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ. <br>Как видим, все действия происходят через один DispatcherServlet.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (403, 'В чем разница между Filters, Listeners and Interceptors?', '<span class="selected_text color_selected_text">Filter</span> выполняет задачи фильтрации либо по пути запроса к ресурсу, либо по пути ответа от ресурса, либо в обоих направлениях. <br>Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext. Фильтры настраиваются в дескрипторе развертывания веб-приложения. <br>При создании цепочки фильтров, веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров. <br>Когда вызывается метод doFilter(...) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод. <br>Зависят от контейнера сервлетов. Могут работать с js, css. <p><span class="selected_text color_selected_text">Interceptor</span> являются аналогом Filter в Spring. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion. <br>Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter, после чего переопределить указанные методы. <br>Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors() внутри класса, который реализует WebMvcConfigurer. <br>Interceptor основан на механизме Reflection, а фильтр основан на обратном вызове функции. <p><span class="selected_text color_selected_text">preHandle</span> — метод используется для обработки запросов, которые еще не были переданы в метод контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению. <br>postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView. <br>afterCompletion — вызывается после отрисовки представления. <br>Listener - это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены. <p>Для веб-приложений дескриптор развёртывания должен называться web. xml и находиться в каталоге WEB-INF, в корне веб-приложения. Этот файл является стандартным дескриптором развёртывания, определённым в спецификации сервлетов. Также есть и другие типы дескрипторов, такие, как файл дескриптора развёртывания sun-web.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (404, 'Можно ли передать в запросе один и тот же параметр несколько раз? Как?', 'Да, можно принять все значения, используя массив в методе контроллера: <p><img class="center" src="images/DBImageInterview/question/404.png" width="500" height="120" alt="image"/>', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (405, 'Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?', 'В кратце, основными блоками Spring Security являются: <p>SecurityContextHolder, чтобы обеспечить доступ к SecurityContext. <br>SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом. <br>Authentication представляет принципала с точки зрения Spring Security. <br>GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения. <br>UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности. <br>UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное). <p>Подробно: <br>Самым фундаментальным явлется SecurityContextHolder. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует MODE_THREADLOCAL для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов: <p>SecurityContextHolder.getContext().getAuthentication().getPrincipal(); <br>UserDetails выступает в качестве принципала. <br>MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности. <br>MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока, наличие аналогичной безопасности. <br>Интерфейс UserDetailsService - подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает UserDetails. Он представляет собой принципала, но в расширенном виде и с учетом специфики приложения. <br>В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который хранится в SecurityContextHolder. <br>Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли). <br>Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п. <br>Процесс аутентификации: <br>1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). <br>2. Токен передается экземпляру AuthenticationManager для проверки. <br>3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. <br>4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. <br>5. При успешной аутентификации можно использовать successHandler. <p><span class="selected_text color_selected_text">Authentication</span> - аутентификация. Процедура проверки подлинности (введеных данных) логин-пароль. <br><span class="selected_text color_selected_text">Authorization</span> - авторизация. Распределение, что пользователь будет видеть, а что нет (что будет скрыто).', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (407, 'Расскажите про нововведения Spring 5.', '●   Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods). <br>●   Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6). <br>●   Поддержка HTTP/2 (TLS, Push), NIO/NIO.2. <br>●   Поддержка Kotlin. <br>●   Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»). <br>●   Null-safety аннотации(@Nullable), новая документация. <br>●   Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0). <br>●   Поддержка JUnit 5 + Testing Improvements (conditional and concurrent). <br>●   Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (421, 'Расскажите про nosql?', 'Базы данных NoSQL предоставляют разнообразные модели данных, такие как пары «ключ-значение», документы и графы. <br>Смягчают жесткие требования свойств ACID ради более гибкой модели данных, которая допускает горизонтальное масштабирование. <br>MongoDB это кросс-платформенная, документо-ориентированная база данных, которая обеспечаивает высокую производительность и лёгкую масштабируемость. В основе данной БД лежит  концепция коллекций и документов. <br>Коллекция – это группа документов MongoDB. Является эквивалентом простой таблицы в реляционной базе данных. <br>Документ – это набор пар “ключ – значение”. Документ имеет динамическую схему.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (431, 'Часто встречающиеся коды ошибок HTTP.', 'Обработка ошибок <br><span class="selected_text color_selected_text">400</span> - Bad Request  Универсальный код ошибки, если серверу непонятен запрос от клиента. <br><span class="selected_text color_selected_text">403</span> - Forbidden  Возвращается, если операция запрещена для текущего пользователя. Если у оператора есть учётка с более высокими правами, он должен перелогиниться самостоятельно. См. также 419. <br><span class="selected_text color_selected_text">404</span> - Not Found   Возвращается, если в запросе был указан неизвестный entity или id несуществующего объекта. Списочные методы get не должны возвращать этот код при верном entity (см. выше). Если запрос вообще не удалось разобрать, следует возвращать 418. <br><span class="selected_text color_selected_text">415</span> - Unsupported Media Type  Возвращается при загрузке файлов на сервер, если фактический формат переданного файла не поддерживается. Также может возвращаться, если не удалось распарсить JSON запроса, или сам запрос пришёл не в формате JSON. <br><span class="selected_text color_selected_text">418</span> - I\\m a Teapot  Возвращается для неизвестных серверу запросов, которые не удалось даже разобрать. Обычно это указывает на ошибку в клиенте, типа ошибки при формировании URI, либо что версии протокола клиента и сервера не совпадают. Этот ответ удобно использовать, чтобы отличать запросы на неизвестные URI (т.е. явные баги клиента) от ответов 404, у которых просто нет данных (элемент не найден). В отличие от 404, код 418 не бросается никаким промежуточным софтом. Альтернатива — использовать для обозначения ситуаций "элемент не найден" 410 Gone, но это не совсем корректно, т.к. предполагает, что ресурс когда-то существовал. Да и выделить баги клиента из потока 404 будет сложнее. <br><span class="selected_text color_selected_text">419</span> - Authentication Timeout Отправляется, если клиенту нужно пройти повторную авторизацию (например, протухли куки или CSRF токены). При этом на клиенте могут быть несохранённые данные, которые будут потеряны, если просто выкинуть клиента на страницу авторизации. <br><span class="selected_text color_selected_text">422</span> - Unprocessable Entity Запрос корректно разобран, но содержание запроса не прошло серверную валидацию. Например, в теле запроса были указаны неизвестные серверу поля, или не были указаны обязательные, или с содержимым полей что-то не так. Обычно это означает ошибку в введённых пользователем данных, но может также быть вызвано ошибкой на клиенте или несовпадением версий. <br><span class="selected_text color_selected_text">500</span> - Internal Server Error Возвращается, если на сервере вылетело необработанное исключение или произошла другая необработанная ошибка времени исполнения. Всё, что может сделать клиент в этом случае — это уведомить пользователя и сделать console.error(err) для более продвинутых товарищей (админов, разработчиков и тестировщиков). <br><span class="selected_text color_selected_text">501</span> - Not Implemented  Возвращается, если текущий метод неприменим (не реализован) к объекту запроса.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (419, 'Что такое репликация данных?', '<span class="selected_text color_selected_text">Репликация</span> — это процесс, под которым понимается копирование данных из одного источника на другой (или на множество других) и наоборот.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (409, 'Жизненный цикл проекта в Maven.', '<span class="selected_text color_selected_text">Проверка — validate.</span> Фреймворк проверяет, корректен ли проект и предоставлена ли вся необходимая для сборки информация. <br><span class="selected_text color_selected_text">Компиляция — compile.</span> Maven компилирует исходники проекта. <br><span class="selected_text color_selected_text">Тест — test.</span> Проверка скомпилированных файлов. <br><span class="selected_text color_selected_text">Сборка проекта — package.</span> По умолчанию осуществляется в формате JAR. Этот параметр можно изменить, добавив в project тег packaging. <br><span class="selected_text color_selected_text">Интеграционное тестирование — integration-test.</span> Maven обрабатывает и при необходимости распаковывает пакет в среду, где будут выполняться интеграционные тесты. <br><span class="selected_text color_selected_text">Верификация — verify.</span> Артефакт проверяется на соответствие критериям качества. <br><span class="selected_text color_selected_text">Инсталляция — install.</span> Артефакт попадает в локальный репозиторий. Теперь его можно использовать в качестве зависимости. <br><span class="selected_text color_selected_text">Размещение проекта в удалённом репозитории — deploy.</span> — финальная стадия работы. <p>Помимо этого есть две фазы, выполняющиеся отдельно, только прямой командой: <br><span class="selected_text color_selected_text">Clean</span> — oчистка, удаляющая предыдущие сборки. <br><span class="selected_text color_selected_text">Site</span> — создание документации для сайта.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (416, 'Расскажите про git. merge vs rebase.', 'Слияние берет все изменения в одной ветке и объединяет их в другую ветку за один коммит. <br>merge принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной. <br>Rebase говорит, что я хочу, чтобы точка, в которой я разветвился, переместилась в новую отправную точку. <br>rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку. В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история. Можно ребейсить только свои ветки, у других могут.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (420, 'Расскажите про Dirty checking механизм Hibernate.', 'По умолчанию Hibernate проверяет все поля управляемых сущностей. Каждый раз, когда объект загружается, Hibernate делает дополнительные копии всех полей сущностей. Во время flush, каждое поле управляемой сущности сравнивается с копией, сделанной во время загрузки. Даже если только одно поле одной сущности изменилось, Hibernate сверит все сущности. <br>С целью ускорить этот процесс пользуйтесь следующими фичами: <p>em.detach / em.clear — открепляют сущности от EntityManager-а. <br>FlushMode=MANUAL- полезен в операциях чтения. <br>@Immutable — также позволяет избежать операций dirty checking.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (425, 'Чем отличаются Mock и Spy?', 'В случае Mock-объекта, единственное, что будут делать все методы такого объекта, если не определять их поведение, – возвращать значения по-умолчанию: void, default-ы для примитивов, пустые коллекции и null для всех остальных объектов. <br>В случае Spy-объекта, по-умолчанию будет исполняться оригинальное поведение методов объекта. <br>Но как и в случае с Mock-объектами, их поведение можно переопределить.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (427, 'Java 8 vs 11', 'Новые методы для Map: PutIfAbsent(), СomputeIfAbsent()\\СomputeIfPresent(), Remove(), GetOrDefault(), Merge(). <br>Новые методы для String: repeat(int), isBlank(), lines(), strip() - это не все. <br>Динамическая типизация с var.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (428, 'CI/CD', 'Continuous Integration/Continuous Delivery. <br>Continuous Integration - методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами в течение суток. <br>Continuous Delivery - постоянная поддержка кода в состоянии готовом для выхода в продакшн. <br>Continuous Integration - это DevOps модель, в которой разработчики делают Commit кода в Repository(GitHub) и автоматически запускаются Build или компиляция этого кода, после этого запускаются автоматические тесты кода: Unit Test, Intagration Test, Functionality Test. <br>Continuous Delivery and Deplyment - это DevOps модель, в которой разработчики делают Commit кода в Repository и автоматически запускаются Build или компиляция этого кода, после этого запускаются автоматические тесты кода и готовый Artifact(скомпилированный код) делает Deploy в Staging, Production.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (432, 'Расскажите про HTTP протокол.', 'HTTP является протоколом прикладного уровня, который чаще всего использует возможности другого протокола - TCP (или TLS - защищённый TCP) - для пересылки и получения сообщений. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). <p>HTTP запросы и ответы имеют близкую структуру. Они состоят из: <br>1. Стартовой строки, описывающей запрос, или статус (успех или сбой). Это всегда одна строка. <br>2. Произвольного набора HTTP заголовков, определяющих запрос или описывающих тело сообщения. <br>3. Пустой строки, указывающей, что вся мета информация отправлена. <br>4. Произвольного тела, содержащего пересылаемые с запросом данные (например, содержимое HTML-формы) или отправляемый в ответ документ. Наличие тела и его размер определяется стартовой строкой и заголовками HTTP. <p>Стартовую строку вместе с заголовками сообщения HTTP называют головой запроса, а его данные - телом. <br>POST -- create <br>GET -- read <br>PUT -- update/replace <br>DELETE -- delete <br>PATCH -- partial update/modify', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (334, 'Чем SCRUM отличается от Kanban?', 'В <span class="selected_text color_selected_text">Scrum</span> наша цель — закончить спринт, в <span class="selected_text color_selected_text">Kanban</span> — задачу. Scrum — это автобус, который идет по маршруту с остановками в конце спринта. А Kanban — это маршрутка: захотел выйти, попросил и вышел там, где нужно.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (424, 'Различие между методами GET и POST?', '<span class="selected_text color_selected_text">GET</span> передает данные в URL в виде пар "имя-значение", данные видны всем в адресной строке браузера. Длина запроса не более 2048 символов. Следует использовать для получения данных от сервера и не желательно в запросах, предполагающих внесений изменений в ресурс. <br><span class="selected_text color_selected_text">POST</span> передает данные в теле запроса. Данные можно увидеть только с помощью инструментов разработчика, расширений браузера. Следует использовать в случаях, когда нужно вносить изменение в ресурс. HTTP метод POST поддерживает тип кодирования данных multipart/form-data, что позволяет передавать файлы.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (84, 'Расскажите про equals и hashcode', '<span class="selected_text color_selected_text">Хеш-код</span> — это целочисленный результат работы метода, которому в качестве входного параметра передан объект. <br>Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. <p><span class="selected_text color_selected_text">Equals</span> - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по equals() идет сравнение по состояниям объектов. <p>Свойства equals(): <br>• Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a) <br>• Рефлексивность: для любого заданного значения x, выражение x.equals(x) должно возвращать true. <br>Заданного — имеется в виду такого, что x != null <br>• Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено. <br>• Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c) <br>• Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode() <p>При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (107, 'Всегда ли выполняется блок finally?', 'Существуют ли ситуации, когда блок finally не будет выполнен?	Да, кроме случаев завершения работы программы или JVM: <p>1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0), <br>2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта. <br>3 - В блоке try{} бесконечный цикл.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (129, 'Что такое сырые типы (raw type)?', '<span class="selected_text color_selected_text">Сырые типы</span> — это типы без указания типа в фигурных скобках - "List list = new ArrayList<>()", они использовались до появления дженериков. <br>Не указывая их, под капотом используется Object.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (176, 'Чем unit тесты отличаются от интеграционных?', 'Тестирование бывает: <br>Блочное (Unit testing) — тестирование одного модуля в изоляции. <br>Интеграционное (Integration Testing) — тестирование группы взаимодействующих модулей. <br>Системное (System Testing) — тестирование системы в целом.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (275, 'Что такое TCL? Какие операции в него входят? Рассказать про них.', 'Операторы управления транзакциями (Transaction Control Language, TCL): <br><span class="selected_text color_selected_text">BEGIN</span> служит для определения начала транзакции. <br><span class="selected_text color_selected_text">COMMIT</span> применяет транзакцию. <br><span class="selected_text color_selected_text">ROLLBACK</span> откатывает все изменения, сделанные в контексте текущей транзакции. <br><span class="selected_text color_selected_text">SAVEPOINT</span> разбивает транзакцию на более мелкие.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (167, 'Как устроена TreeMap, сложность основных операций?', '<img class="center" src="images/DBImageInterview/question/167.webp" width="500" height="200" alt="image"/><p>\r\n\r\nКласс TreeMap<K, V> представляет отображение в виде самосбалансирующее красно-черное дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (393, 'Расскажите про жизненный цикл бина.', '1) Парсирование конфигурации и создание BeanDefinition <br>2) Настройка созданных BeanDefinition <br>3) Создание кастомных FactoryBean <br>4) Создание экземпляров бинов <br>5) Настройка созданных бинов <br>6) Бины созданы <br>7) Закрытие контекста', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (87, 'Правила переопределения equals()', '1. Проверить на равенство ссылки объектов this и параметра метода o. <br>if (this == o) return true; <br>2. Проверить, определена ли ссылка o, т. е. является ли она null. <br>Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object. <br>3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем. <br>4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o) <br>5. Выполнить преобразование типа параметра o к требуемому классу. <br>6.  Выполнить сравнение всех значимых полей объектов: <br>  -  для примитивных типов (кроме float и double), используя оператор == <br> - для ссылочных полей необходимо вызвать их метод equals <br> - для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals() <br> - для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (210, 'Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?', '<span class="selected_text color_selected_text">Big O (O большое / символ Ландау)</span> - математическое обозначение порядка функции для сравнения асимптотического поведения функций. <br><span class="selected_text color_selected_text">Асимптотика</span> - характер изменения функции при стремлении ее аргумента к определённой точке. <br>Любой алгоритм состоит из неделимых операций процессора(шагов), поэтому нужно измерять время в операциях процессора, вместо секунд. <br><span class="selected_text color_selected_text">DTIME</span> - количество шагов(операций процессора), необходимых, чтобы алгоритм завершился. <br>Временная сложность обычно оценивается путём подсчёта числа элементарных операций, осуществляемых алгоритмом. Время исполнения одной такой операции при этом берётся константой, то есть асимптотически оценивается как O(1). <br>Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти. Временная сложность - функция, представляющая зависимость количество операций процессора, необходимых, чтобы алгоритм завершился, от размера входных данных. Все неделимые операции языка(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процессора, эта погрешность считается приемлемой. При росте N, слагаемые с меньшей скорость роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, слагаемое с большей скорость роста определяет значение функции. Данное слагаемое называют порядком функции. Пример: Т(N) = 5 * N^2 + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми функции. Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2). <p><img class="center" src="images/DBImageInterview/question/210.png" width="600" height="300" alt="image"/><p> <p>В порядке возрастания сложности: <br>1. O(1) - константная, чтение по индексу из массива <br>2. O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве <br>3. O(√n) - сублинейная <br>4. O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве <br>5. O(n*log(n)) - квазилинейная, сортировка слиянием, сортировка кучей <br>6. O(n^2) - полиномиальная(квадратичная), вложенный цикл, перебор двумерного массива, сортировка пузырьком, сортировка вставками <br>7. O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел <br>8. O(n!) - факториальная, решение задачи коммивояжёра полным перебором <p>Алгоритм считается приемлемым, если сложность не превышает O(n*log(n)), иначе го***код.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (274, 'Что такое DML? Какие операции в него входят? Рассказать про них.', 'Операторы манипуляции данными (Data Manipulation Language, DML): <br><span class="selected_text color_selected_text">SELECT</span> выбирает данные, удовлетворяющие заданным условиям. <br><span class="selected_text color_selected_text">INSERT</span> добавляет новые данные. <br><span class="selected_text color_selected_text">UPDATE</span> изменяет существующие данные. <br><span class="selected_text color_selected_text">DELETE</span> удаляет данные при выполнении условия WHERE.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (139, 'Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)', 'Никаких модификаций не допускается. Изменений структуры коллекции, уменьшать, добавлять... <br>Итератор fail-safe проходимся по коллекции и не вылетает ошибка при попытке удалить элемент, не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном. <br>Пример fail-safe - Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap. <p>Итератор fail-fast проходя по коллекции вылетает ошибка, т.к. проходим по коллекции пытаемся удалить элемент, генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее. <br>Пример fail-fast - Vector и Hashtable. <p>fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. <br>В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора. <br>Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count): <br>● при изменении коллекции счетчик модификаций также изменяется; <br>● при создании итератора ему передается текущее значение счетчика; <br>● при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение. <p>Разница, при удалении значений и при добавлении значений. Добавление в конец, удаление может быть где удобно. <p><span class="selected_text color_selected_text">Fail-safe</span> – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»). Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений. Плата за отсутствие ошибок других fail-safe итераторов может отличаться, детали всегда можно найти в документации коллекций. <br><span class="selected_text color_selected_text">Fail-fast</span> – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, он падает с ошибкой без лишних разбирательств. Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException. Рекомендуется не основывать логику программы на fail-fast отказах, и использовать их только как признак ошибки реализации.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (187, 'Расскажите про метод peek() в Stream.', 'Предполагается, что map() получает на вход один объект, а возвращает другой. Возможно, того же типа, но другой. peek() - это частный случай map(), который возвращает тот же самый объект, который получил на входе, возможно, с изменённым внутренним состоянием. Конечно, можно использовать для этого map(), но есть нюансы. <br>Во-первых, peek() на одну строчку короче - не нужно писать return, Java и так знает, что нужно возвращать. <br>Во-вторых, вы страхуетесь от ошибок - из peek() невозможно вернуть не тот объект, который пришёл на вход.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (189, 'Расскажите про метод flatMap() в Stream.', 'Метод flatMap() возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (24, 'Расскажи про Stack и Heap', 'Память процесса делится на Stack (стек) и Heap (куча): <br>- Stack содержит staсk frame-ы, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные. <br>- Структура Heap зависит от выбранного сборщика мусора. Читай про GC! <p>MetaSpace - специальное пространство кучи, отделенное от кучи основной памяти. JVM хранит здесь весь статический контент. Это включает в себя все статические методы, примитивные переменные и ссылки на статические объекты. Кроме того, он содержит данные о байт-коде, именах и JIT-информации. До Java 7 String Pool также был частью этой памяти. <br>С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека. <br>- Heap - используется всем приложением, Stack - одним потоком исполняемой программы. <br>- Новый объект создается в heap, в stack размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов. <br>- Объекты в куче доступны из любого места программы, стековая память не доступна для других потоков. <br>- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError. <br>- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи. <br>- В куче есть ссылки между объектами и их классами. На этом основана рефлексия. <br>Обе области хранятся в RAM. (оперативная память)', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (35, 'Почему строки не рекомендуется использовать для хранения паролей?', '1. Пул строк <br>Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно. <p>2. Рекомендации авторов <br>Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char[]. <p>3. Случайная печать в логах <br>С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (301, 'Что такое временные таблицы? Для чего они нужны?', 'Подобные таблицы удобны для каких-то временных промежуточных выборок из нескольких таблиц. <br>Создание временной таблицы начинается со знака решетки #. Если используется один знак #, то создается локальная таблица, которая доступна в течение текущей сессии. Ели используются два знака ##, то создается глобальная временная таблица. В отличие от локальной глобальная временная таблица доступна всем открытым сессиям базы данных. <p>CREATE TABLE #ProductSummary <br>(ProdId INT IDENTITY, <br>ProdName NVARCHAR(20), <br>Price MONEY)', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (50, 'Каким образом из вложенного класса получить доступ к полю внешнего класса?', 'Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. <br>Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую. <p>В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (56, 'Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?', '-У конструктора по умолчанию отсутствуют какие-либо аргументы. <br>-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. <br>-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (136, 'Расскажите про интерфейс Set.', 'Интерфейс Set расширяет интерфейс Collection. <br>Set не добавляет новых методов, только вносит изменения унаследованные. <br>Set - неупорядоченный набор неповторяющихся элементов. <br>В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента. <br>Разрешено наличие только одной ссылки типа null. <p>Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet? <br>EnumSet - это реализация интерфейса Set для использования с перечислениями (Enum). В структуре данных хранятся объекты только одного типа Enum, указываемого при создании. Для хранения значений EnumSet использует массив битов (bit vector), - это позволяет получить высокую компактность и эффективность. Проход по EnumSet осуществляется согласно порядку объявления элементов перечисления. <br>Все основные операции выполняются за O(1) и обычно (но негарантированно) быстрей аналогов из HashSet, а пакетные операции (bulk operations), такие как containsAll() и retainAll() выполняются даже гораздо быстрей. <br>Помимо всего EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (73, 'Чем интерфейсы отличаются от абстрактных классов?', 'В каких случаях следует использовать абстрактный класс, а в каких интерфейс? 1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть. <br>2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы. <br>3. Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом. <br>4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8-й версии.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (71, 'Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 'Да. Необходимы для наследников. <p>В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (94, 'Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?', 'В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. <br>Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (112, 'Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?', 'В try-with-resources добавлена возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия. <br>Можно достать с помощью метода getSuppressed из исключения, создаваемое блоком  try', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (117, 'Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', '1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null. <p>2) Сделать поле static. Значения статических полей автоматически не сохраняются. <p>3) Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем необходимо использовать только стандартную сериализацию.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (119, 'Какая роль поля serialVersionUID в сериализации?', 'Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. <br>Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение. <br>Если мы не объявляем его явно, Java делает это за нас.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (130, 'Что такое вайлдкарды?', 'Маске (wildcard) можно задать ограничения: <br>- “? extends T” (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность. <br>  Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null. <br>- “? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object <p>При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (142, 'Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?', 'Можно, но нужно использовать iterator.remove(). <br>Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет ConcurrentModificationException. <p>Как избежать ConcurrentModificationException во время перебора коллекции? <br> ● Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для List можно использовать ListIterator. <br> ● Использовать ConcurrentHashMap и CopyOnWriteArrayList. <br> ● Преобразовать список в массив и перебирать массив. <br> ● Блокировать изменения списка на время перебора с помощью блока synchronized. <br>Отрицательная сторона последних двух вариантов - ухудшение производительности. <p>remove() - удаляет элемент, который был возвращен последним вызовом next. <br>Класс ConcurrentModificationException. Это исключение может быть выдано методами, которые обнаружили параллельную модификацию объекта, когда такая модификация не допустима.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (144, 'Чем Set отличается от List?', 'List - это упорядоченная последовательность элементов, можно получить по индексу, тогда как Set - это отдельный список элементов, который не упорядочен. <br>List допускает дублирование, а Set не допускает дублирование элементов. <br>List разрешает любое количество нулевых значений в своей коллекции, а Set разрешает только одно нулевое значение в своей коллекции. <br>List может быть вставлен как в прямом, так и в обратном направлении с помощью Listiterator, тогда как Set можно просматривать только в прямом направлении с помощью итератора. <p>Set не добавляет новых методов, только вносит изменения унаследованные. <br>В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (157, 'Чем отличаются ArrayList и LinkedList?', 'Отличие двух коллекций ArrayList и LinkedList связано со способом хранения данных. Реализация ArrayList хранит элементы в виде массива, а LinkedList - в виде списка (двунаправленного). <br>Кроме этого, в ArrayList быстрее выполняется сортировка, поскольку для ее выполнения данные списка копируются в массив, а копировать из массива ArrayList в массив для сортировки быстрее. <br>При большом количестве операций добавления и удаления элементов в коллекцию LinkedList должен быть более приемлемым, т.к. при этих операциях не приходится перемещать части массива.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (226, 'Как работают методы wait(), notify() и notifyAll()?', '<span class="selected_text color_selected_text">wait()</span>: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll(); <br><span class="selected_text color_selected_text">notify()</span>: продолжает работу потока, у которого ранее был вызван метод wait(); <br><span class="selected_text color_selected_text">notifyAll()</span>: возобновляет работу всех потоков, у которых ранее был вызван метод wait(). <br>Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит. <br><span class="selected_text color_selected_text">wait(), notify()</span> и <span class="selected_text color_selected_text">notifyAll()</span> должны вызываться только из синхронизированного кода.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (211, 'Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.', '<span class="selected_text color_selected_text">Рекурсия</span> - способ отображения какого-либо процесса внутри самого этого процесса, то есть ситуация, когда процесс является частью самого себя. <br>Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1. <br>В базовом случае обязательно  присутствует условие выхода из рекурсии. <br>Смысл рекурсии в движении от исходной задачи к базовому случаю, пошагово уменьшая размер исходной задачи на каждом шаге рекурсии. <br>После того, как будет найден базовый случай, срабатывает условие выхода из рекурсии, и стек рекурсивных вызовов разворачивается в обратном порядке, пересчитывая результат исходной задачи, который основан на результате, найденном в базовом случае. <br>Так работает рекурсивное вычисление факториала: <br><img class="center" src="images/DBImageInterview/question/211.1.png" width="550" height="90" alt="image"/> <br>Или даже так: <br><img class="center" src="images/DBImageInterview/question/211.2.png" width="320" height="25" alt="image"/> <br>Рекурсия имеет линейную сложность O(n); <p>Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов. <br>Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти. <br>В случае рекурсии стек вызовов разрастается, и его необходимо просматривать для получения конечного ответа. <br>При использовании головной рекурсии также необходимо принимать во внимание размер стека. <br>Если уровней вложенности много или изменятся, то предпочтительна рекурсия. Если их несколько, то лучше цикл.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (254, 'Назовите три основные группы паттернов.', '<span class="selected_text color_selected_text">Порождающие</span> - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей. <br><span class="selected_text color_selected_text">Структурные</span> - отвечают за построение удобных в поддержке иерархий классов. <br><span class="selected_text color_selected_text">Поведенческие</span> - заботятся об эффективной коммуникации между объектами.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (369, 'Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?', '<img class="center" src="images/DBImageInterview/question/369.png" width="500" height="200" alt="image"/> <p><span class="selected_text color_selected_text">ApplicationContext</span> является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов. <br><span class="selected_text color_selected_text">BeanFactory</span> - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов. Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. Эти зависимости отражены в данных конфигурации, используемых BeanFactory. Может работать с бинами singleton и prototype. <br>BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext. <br>ApplicationContext загружает все бины при запуске, а BeanFactory по требованию.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (241, 'Что такое race condition?', '<span class="selected_text color_selected_text">Состояние гонки (race condition)</span> - ошибка проектирования многопоточной системы или приложения, при которой работа зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки. <br><span class="selected_text color_selected_text">DataRace</span> - это свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before». <br><span class="selected_text color_selected_text">Starvation</span> - потоки не заблокированы, но есть нехватка ресурсов из-за чего потоки ничего не делают. <p>Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками. <p><span class="selected_text color_selected_text">Недетерминированные ошибки</span> являются случайными, присущими данному методу анализа. <br><span class="selected_text color_selected_text">DataRace</span> - гонка данных. Когда несколько потоков обращаются к одной переменной.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (252, 'Что такое «шаблон проектирования»? ', 'Проверенное и готовое к использованию логическое решение, которе может быть реализовано по-разному в разных языках программирования. <p>Плюсы: <br>Снижение сложности разработки за счёт готовых абстракций. <br>Облегчение коммуникации между разработчиками. <br>Минусы: <br>Слепое следование некоторому шаблону может привести к усложнению программы. <br>Желание попробовать некоторый шаблон в деле без особых на то оснований.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (83, 'Какие методы есть у класса Object (перечислить все)? Что они делают?', '- <span class="selected_text color_selected_text">equals()</span> - проверка на равенство двух объектов. <br>- <span class="selected_text color_selected_text">hashCode()</span> - изначально случайно число int. <br>- <span class="selected_text color_selected_text">toString()</span> - представления данного объекта в виде строки. <br>- <span class="selected_text color_selected_text">getClass()</span> - получение типа данного объекта. <br>- <span class="selected_text color_selected_text">clone()</span> -  клонирует объект методом. <br>- <span class="selected_text color_selected_text">finalize()</span> - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван). <p>для многопоточки <br>- <span class="selected_text color_selected_text">notify()</span> - «размораживает» одну случайную нить. <br>- <span class="selected_text color_selected_text">notifyAll()</span> - «размораживает» все нити данного монитора. <br>- <span class="selected_text color_selected_text">wait()</span> - нить освобождает монитор и «становится на паузу». <br>- <span class="selected_text color_selected_text">wait(long timeOut)</span> - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах. <br>- <span class="selected_text color_selected_text">wait(long timeOut, int nanos)</span> - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (259, 'Расскажите про паттерн Фабричный метод (Factory Method).', 'Порождающий шаблон проектирования, в котором подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта. <br>Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. <br>Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу. <p> <span class="selected_text color_selected_text">+</span> : Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип открытости/закрытости. <br> <span class="selected_text color_selected_text">-</span> : Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя. <p>Фабрика, фабричный метод - внутри инкапсулирует логику, которая создает новый объект. <br>пример: фабрика сессий создает фабрику, бин фактори (внутри инкапсулирует создание бин дифинишенл).', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (386, 'Расскажите про создание кастомных FactoryBean.', '<span class="selected_text color_selected_text">FactoryBean</span> — это generic интерфейс, которому можно делегировать процесс создания бинов типа. В те времена, когда конфигурация была исключительно в xml, разработчикам был необходим механизм с помощью которого они бы могли управлять процессом создания бинов. Именно для этого и был сделан этот интерфейс. <br>Создадим фабрику которая будет отвечать за создание всех бинов типа — Color. <p><img class="center" src="images/DBImageInterview/question/386.png" width="800" height="400" alt="image"/> <p>Теперь создание бина типа Color.class будет делегироваться ColorFactory, у которого при каждом создании нового бина будет вызываться метод getObject. <br>Для тех кто пользуется JavaConfig, этот интерфейс будет абсолютно бесполезен.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (277, 'Нюансы работы с NULL в SQL. Как проверить поле на NULL?', '<span class="selected_text color_selected_text">NULL</span> - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения». <br>NULL означает отсутствие, неизвестность информации. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении NULL с любым значением будет получен результат NULL, а не FALSE и не 0. Более того, NULL не равно NULL! <br>Команды: IS NULL, IS NOT NULL.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (282, 'Чем WHERE отличается от HAVING? (ответа про то что используются в разных частях запроса - недостаточно)', 'WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже). <br>В HAVING можно использовать псевдонимы только если они используются для наименования результата агрегатной функции, в WHERE можно всегда. <br>HAVING стоит после GROUP BY, но может использоваться и без него. При отсутствии предложения GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну строку, если выходной набор не пуст.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (287, 'Что такое EXISTS?', 'Оператор EXISTS используется для проверки наличия любой записи в подзапросе. <br>Оператор EXISTS возвращает true, если подзапрос возвращает одну или несколько записей. <p><img class="center" src="images/DBImageInterview/question/287.png" width="350" height="85" alt="image"/><p>', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (294, 'Что такое индексы? Какие они бывают?', 'Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает структуру для индексируемого поля. Необходимо просто добавить указатель индекса в таблицу. <p>Есть три типа индексов, а именно: <br>Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения. Если первичный ключ определен, уникальный индекс применен автоматически. <br>По воздействию на источник данных: <br>Кластеризованный индекс (Clustered Index): сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. Это ускоряет операции чтения из БД. <br>Некластеризованный индекс (Non-Clustered Index): внутри таблицы есть упорядоченный список, содержащий значения ключа некластеризованного индекса и указатель на строку данных, содержащую значение ключа. Каждый новый индекс увеличивает время, необходимое для создания новых записей из-за упорядочивания. Каждая таблица может иметь много некластеризованных индексов. <p>Преимущества <br>● ускорение поиска и сортировки по определенному полю или набору полей. <br>● обеспечение уникальности данных. <br>Недостатки <br>● требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса. <br>● замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы. <br>Индексы предпочтительней для: <br>● Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле; <br>● Поля, по которому проводится сортировка данных; <br>● Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее; <br>● Поля, которое объявлено первичным ключом (primary key); <br>● Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом. <br>Использование индексов нецелесообразно для: <br>● Полей, которые редко используются в запросах; <br>● Полей, которые содержат всего два или три значения, например: мужской, женский пол или значения «да», «нет».', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (316, 'Что такое EntityManager?', 'EntityManager интерфейс JPA, который описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. <br> Основные операции: <br>1) Операции над Entity: persist (добавление Entity), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread). <br>2) Получение данных: find (поиск и получение Entity), createQuery (создать объект Query для выполнения JPQL запроса), createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery. <br>3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate. <br>4) Работа с EntityGraph: createEntityGraph, getEntityGraph. <br>5) Общие операции над EntityManager или всеми Entities: close, clear, isOpen, getProperties, setProperty. <p>Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (212, 'Что такое жадные алгоритмы? Приведите пример.', 'Жадные алгоритмы являются одной из 3х техник создания алгоритмов, вместе с принципом "Разделяй и властвуй" и динамическим программированием. <br><span class="selected_text color_selected_text">Жадный алгоритм</span> - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги. Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению. <br>Т.е. задача разбивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению. <br>К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (221, 'Чем процесс отличается от потока?', '<span class="selected_text color_selected_text">Процесс</span> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. <br>Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое. <br>Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память. <br><span class="selected_text color_selected_text">Поток (thread)</span> — способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. <br>Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов. <p>Методы: sleep, join, yield.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (343, 'Что такое каскады?', '<span class="selected_text color_selected_text">Каскадирование</span> - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity. <br>JPA CascadeType: <br><span class="selected_text color_selected_text">ALL</span> -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту. <br><span class="selected_text color_selected_text">PERSIST</span> -  означает, что операции save() или persist() каскадно передаются связанным объектам. <br><span class="selected_text color_selected_text">MERGE</span> - означает, что связанные entity объединяются, когда объединяется entity-владелец. <br><span class="selected_text color_selected_text">REMOVE</span> - удаляет все entity, связанные с удаляемой entity. <br><span class="selected_text color_selected_text">DETACH</span> - отключает все связанные entity, если происходит «ручное отключение». <br><span class="selected_text color_selected_text">REFRESH</span> - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh(). <p><span class="selected_text color_selected_text">orphanRemoval</span> - Директива orphanRemoval объявляет, что связанные экземпляры сущностей должны быть удалены, когда они отсоединены от родителя, или эквивалентно, когда родитель удален. <br><span class="selected_text color_selected_text">save()</span> - сохраняет объект в БД, генерируя новый Id, даже если он установлен.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (350, 'Для чего нужна аннотация @Basic?', '@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов: <br>1. Примитивы и их обертки <br>2. java.lang.String <br>3. java.math.BigInteger <br>4. java.math.BigDecimal <br>5. java.util.Date <br>6. java.util.Calendar <br>7. java.sql.Date <br>8. java.sql.Time <br>9. java.sql.Timestamp <br>10. byte[] or Byte[] <br>11. char[] or Character[] <br>12. enums <br>13. любые другие типы, которые реализуют Serializable <br>Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию. <p>Аннотация @Basic определяет 2 атрибута: <br>1. <span class="selected_text color_selected_text">optional</span> - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение. <br>2. <span class="selected_text color_selected_text">fetch</span> - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка. <p>Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (351, 'Для чего нужна аннотация @Column?', '@Column сопоставляет поле класса столбцу таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных. <p>@Basic vs @Column: <br>1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных. <br>2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет. С другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null. <br>3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво. <br>4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств: <br> a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true. <br> b. length - длина, для строковых типов данных, по умолчанию 255. <br>Коротко, в Column мы задаем constraints, а в Basic - FetchType.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (352, 'Для чего нужна аннотация @Access?', 'Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сеттеры (setter). <p>Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода: <br>1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их. <br>2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. <br>По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY. <br>Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами. <br>Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса. <br>Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (255, 'Расскажите про паттерн Одиночка (Singleton).', 'Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. <br>Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан. <p><img class="center" src="images/DBImageInterview/question/255.png" width="300" height="200" alt="image"/><p> <span class="selected_text color_selected_text">+</span> : можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним. <br><span class="selected_text color_selected_text">-</span> : нарушает принцип единой ответственности, так как его могут использовать множество объектов.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (302, 'Что такое транзакции? Расскажите про принципы ACID.', '<span class="selected_text color_selected_text">Транзакция</span> - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных. <p><span class="selected_text color_selected_text">ACID</span>-принципы транзакций: <br><span class="selected_text color_selected_text">• Атомарность (atomicity)</span> гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция представляет одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей транзакции и состояние базы данных остается неизменным. <br><span class="selected_text color_selected_text">• Согласованность (consistency)</span> Транзакция, достигающая своего завершения и фиксирующая свои результаты, сохраняет согласованность базы данных. <br><span class="selected_text color_selected_text">• Изолированность (isolation)</span> Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат. <br><span class="selected_text color_selected_text">• Долговечность (durability)</span> Независимо от проблем (к примеру, потеря питания, сбой или ошибки любого рода) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу. <p><span class="selected_text color_selected_text">Consistency (согласованность)</span> — гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (303, 'Расскажите про уровни изолированности транзакций.', 'В порядке увеличения изолированности транзакций и, соответственно, надежности работы с данными: <br><span class="selected_text color_selected_text">• Чтение неподтверждённых данных (read uncommitted)</span> — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Возможны неповторяемое чтение, фантомы и грязное чтение. <br><span class="selected_text color_selected_text">• Чтение подтвержденных данных (read committed)</span> — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций, но процессы-писатели могут изменять уже прочитанные читателем данные. Возможны неповторяемое чтение и фантомы. <br><span class="selected_text color_selected_text">• Повторяемость чтения (repeatable read)</span> — Уровень, позволяющий предотвратить неповторяемое чтение. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи этой же или другой транзакцией. Но все еще видим вставленные записи из другой транзакции. В MySQL и PostgreSQL отсутствует эффект чтения фантомов для этого уровня. <br><span class="selected_text color_selected_text">• Упорядочиваемость (serializable)</span> — гарантирует неизменяемость данных другими процессами до завершения транзакции. Проблемы синхронизации не возникают. <p>При параллельном выполнении транзакций возможны следующие проблемы: <br><span class="selected_text color_selected_text">Потерянное обновление (lost update)</span> — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется; <br><span class="selected_text color_selected_text">Грязное» чтение (dirty read)</span> — чтение данных, добавленных или измененных транзакцией, которая впоследствии не подтвердится (откатится); <br><span class="selected_text color_selected_text">Неповторяющееся чтение (non-repeatable read)</span> — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются измененными; <br><span class="selected_text color_selected_text">Фантомное чтение (phantom reads)</span> — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей. <p>Чем выше уровень изолированности, тем ниже скорость выполнения <p><span class="selected_text color_selected_text">Serializable</span> <br>Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг на друга нет. В классическом представлении этот уровень избавляет от эффекта чтения фантомов.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (313, 'Что такое JPA?', '<span class="selected_text color_selected_text">JPA(Java Persistence API)</span> - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (325, 'Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?', 'Inheritance Mapping Strategies описывает как JPA будет работать с классами-наследниками Entity: <br><span class="selected_text color_selected_text">1) Одна таблица на всю иерархию классов (SINGLE_TABLE)</span> — все entity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при этом имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно. Нельзя делать констраинт notNull, но можно использовать триггеры. <br><span class="selected_text color_selected_text">2) Стратегия «соединения» (JOINED)</span> — в этой стратегии каждый класс entity сохраняет данные в свою таблицу, но только уникальные поля (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций. <br><span class="selected_text color_selected_text">3) Таблица для каждого класса (TABLE_PER_CLASS)</span> — каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса. <p>Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки).', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (326, 'Как мапятся Enum&#39ы?', '<span class="selected_text color_selected_text">@Enumerated(EnumType.STRING)</span> - означает, что в базе будут храниться имена Enum. мы можем безопасно добавлять новые значения перечисления или изменять порядок нашего перечисления. Однако переименование значения перечисления все равно нарушит данные базы данных. <br>Кроме того, несмотря на то, что это представление данных намного удобнее для чтения по сравнению с параметром @Enumerated(EnumType.ORDINAL), оно также занимает гораздо больше места, чем необходимо. <br><span class="selected_text color_selected_text">@Enumerated(EnumType.ORDINAL)</span> - в базе будут храниться порядковые номера Enum. Если мы добавим новое значение в середине или изменим порядок перечисления, мы сломаем существующую модель данных. Такие проблемы может быть трудно обнаружить, а также проблематично исправить, поскольку нам придется обновить все записи базы данных. <br>Другой вариант - мы можем смапить наши enum в БД и обратно в методах с аннотациями @PostLoad и @PrePersist. @EntityListener над классом Entity, в которой указать класс, в котором создать два метода, помеченных этими аннотациями. <br>Идея в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля. <br>Несмотря на то, что этот вариант дает нам больше гибкости в выборе представления значения базы данных по сравнению с ранее описанными решениями, он не идеален. Просто неправильно иметь два атрибута, представляющих одно перечисление в сущности. Кроме того, если мы используем этот тип сопоставления, мы не сможем использовать значение перечисления в запросах JPQL. <br>В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует javax.persistence.AttributeConverter и аннотировать его с помощью @Converter и поле в сущности аннотацией @Convert.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (328, 'Как “смапить” коллекцию примитивов?', '<span class="selected_text color_selected_text">@ElementCollection</span> <br><span class="selected_text color_selected_text">@OrderBy</span> <br>Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов. <br>При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью <span class="selected_text color_selected_text">@OrderColumn</span>. <br><span class="selected_text color_selected_text">@CollectionTable</span> - позволяет редактировать таблицу с коллекцией, прочитать.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (346, 'Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?', 'Transient (New) — свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе данных и не имеет сгенерированных первичных ключей. <br><span class="selected_text color_selected_text">managed</span> - объект создан, сохранён в бд, имеет primary key, управляется JPA. <br><span class="selected_text color_selected_text">detached</span> - объект создан, не управляется JPA. В этом состоянии сущность не связана со своим контекстом (отделена от него) и нет экземпляра Session, который бы ей управлял. <br><span class="selected_text color_selected_text">removed</span> - объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached. <p>Перейти в detached состояние сущность может по следующим причинам: <br>Явный перевод из persisted в detached вызовом метода evict() у Session. <br>Сброс контекста методом clear() у Session. <br>Явное закрытие сессии методом close(). <br>Неявное закрытие сессии связанное с удалением объекта Session. <br>Над detached объектом нельзя выполнять операции, которые требуют наличия PersistenceContext.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (29, 'Что такое автоупаковка и автораспаковка?', '<span class="selected_text color_selected_text">Автоупаковка</span> - присвоение классу обертки значения примитивного типа. <p><span class="selected_text color_selected_text">Автораспаковка</span> - присвоение переменной примитивного типа значение класса обертки. <p>Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически. <br>Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (354, 'Для чего нужна аннотация @Cache?', 'Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра: <br><span class="selected_text color_selected_text">❖ include</span> - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты. <br><span class="selected_text color_selected_text">❖ region</span> - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”. <br><span class="selected_text color_selected_text">❖  usage</span> - задаёт стратегию одновременного доступа к объектам. <p>transactional <br>read-write <br>nonstrict-read-write <br>read-only', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (357, 'Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?', '@JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. <br>Особенности использования: <br>❖ @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности. <br>❖ @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами. <br>@JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа. <br>В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName. <br>@JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (372, 'Чем отличаются аннотации @Bean и @Component?', '<span class="selected_text color_selected_text">@Bean</span> - ставится над методом и позволяет добавить bean, уже реализованного сторонней библиотекой класса, в контейнер, а <span class="selected_text color_selected_text">@Component</span> используется для указания класса, написанного программистом.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (121, 'В чем проблема сериализации Singleton?', '- Проблема в том что после десериализации мы получим другой объект. <br>Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно. <p>- Решение <br>В классе определяется метод с сигнатурой "Object readResolve() throws ObjectStreamException" <br>- Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (373, 'Расскажите про аннотации @Service и @Repository. Чем они отличаются?', '<span class="selected_text color_selected_text">@Repository</span> - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО. <br>@Service - указывает, что класс является сервисом для реализации бизнес-логики. <br>@Repository, @Service, @Controller и @Configuration являются алиасами @Component, их также называют стереотипными аннотациями. <p>Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно не проверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (374, 'Расскажите про аннотацию @Autowired', '<span class="selected_text color_selected_text">@Autowired</span> – автоматическое внедрение подходящего бина: <br>1) Контейнер определяет тип объекта для внедрения. <br>2) Контейнер ищет соответствующий тип бина в контексте(он же контейнер). <br>3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он. <br>4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять. <br>5) В противном случае контейнер внедрит бин, основываясь на его имени или ID. <br>6) Если ни один из способов не сработал, то будет выброшено исключение. <br>Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP. <br>В аннотации есть один параметр required = true/false - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false. <br>При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором. <br>    Однако при внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Это означает, что: <br>    Существует способ (путем вызова конструктора по-умолчанию) создать объект с использованием new в состоянии, когда ему не хватает некоторых из его обязательных зависимостей, и использование приведет к NullPointerException <br>    Такой класс не может быть использован вне DI-контейнеров (тесты, другие модули) и нет способа кроме рефлексии предоставить ему необходимые зависимости <br>    Неизменность <br>В отличие от способа с использованием конструктора, внедрение через поля не может использоваться для присвоения зависимостей final-полям, что приводит к тому, что ваши объекты становятся изменяемыми.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (25, 'Какие примитивные типы данных есть в Java?', 'Вещественные, целочисленные, логические и строковые. <br>byte <br>short <br>int <br>long <br>float <br>double <br>char <br>boolean', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (28, 'Что такое классы-обертки?', '<span class="selected_text color_selected_text">Обертка</span> — это специальный класс, который хранит внутри себя значение примитива (объекты классов-оберток являются неизменяемыми (Immutable)). <br>Нужны для реализации дженериков.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (30, 'Что такое явное и неявное приведение типов?', 'В каких случаях в java нужно использовать явное приведение?	<span class="selected_text color_selected_text">Неявное приведение</span> – автоматическое расширение типа переменной от меньшего к большему. <p><span class="selected_text color_selected_text">Явное приведение</span> -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип. <p>В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (31, 'Что такое пул интов?', 'В Java есть пул (pool) целых чисел в промежутке [-128;127], так как это самый часто встречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. <br>Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (39, 'Можно ли использовать строки в конструкции switch?', 'Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. <p>При этом: <br>- участвующие строки чувствительны к регистру; <br>- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else; <br>- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException;', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (42, 'Какими значениями инициируются переменные по умолчанию?', 'byte - 0 <br>short - 0 <br>int - 0 <br>long - 0L <br>float - 0.0f <br>double - 0.0d <br>char - u0000 <br>boolean - false <br>Объекты - null <br>Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса. <br>Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (311, 'Что такое «триггер»?', '<span class="selected_text color_selected_text">Триггер (trigger)</span> — это хранимая процедура особого типа, исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. <br>Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события). INSTEAD OF — вместо.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (47, 'Расскажите про вложенные классы.', 'В каких случаях они применяются? Нужны для обслуживания внешних классов <p>1. Статические вложенные классы (Static nested classes) <br> -        Есть возможность обращения к внутренним статическим полям и методам класса обертки. <br>2. Вложенные классы <br> - Есть возможность обращения к внутренним полям и методам класса обертки. <br> - Не может иметь статических объявлений. <br> - Внутри такого класса нельзя объявить перечисления. <br> - Если нужно явно получить this внешнего класса — OuterClass.this. <br>3. Локальный класс <br> - Видны только в пределах блока, в котором объявлены. <br> - Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально). <br> - Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final). <br> - Имеют доступ к полям и методам обрамляющего класса. <br> - Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final. <br>4. Анонимные классы <br> - Локальный класс без имени.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (48, 'Что такое «локальный класс»? Каковы его особенности?', 'Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе. <br>Особенности: <br>Локальные классы способны работать только с final переменными метода. <br>С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться. <br>Локальные классы нельзя объявлять с модификаторами доступа. <br>Локальные классы обладают доступом к переменным метода. <br>Может быть создан внутри блоков инициализации. <p>С java 8 появилось понятие — effectively final . Применяется оно только к переменным (в том числе аргументам методов). Суть в том, что не смотря на явное отсутствие ключевого слова final, значение переменной не изменяется после инициализации.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (51, 'Что такое перечисления (enum)?', 'Перечисления представляют набор логически связанных констант. <p>Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее. <p>Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. <br>Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант. <br>Методы: <br> - ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0) <br> - values() возвращает массив всех констант перечисления <p>Еnum имеет ряд преимуществ при использовании в сравнении с static final int. <br>Главным отличием является то что используя enum вы можете проверить тип данных. <p>Недостатки <br> - К ним не применимы операторы >, <, >=, <= <br> - enum также требует больше памяти для хранения чем обычная константа. <p>Нужны для ограничения области допустимых значений: например, времена года, дни недели.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (52, 'Как проблема ромбовидного наследования (множественное наследование) решена в java?', 'В Java нет поддержки множественного наследования классов. <p>Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов. <p>1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов. <br>2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B. <br>3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (55, 'Расскажите про классы-загрузчики и про динамическую загрузку классов.', 'При запуске JVM, используются три загрузчика классов: <p>- Bootstrap ClassLoader - главный загрузчик <br>- загружает платформенные классы JDK из архива rt.jar <p>- AppClassLoader - системный загрузчик <br>- загружает классы приложения, определенные в CLASSPATH <p>- Extension ClassLoader - загрузчик расширений <br>- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext. <p>Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (58, 'Что означает модификатор static?', 'Статическая переменная - это переменная, принадлежащая классу, а не объекту. <br>А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса. <br>Внутри static метода нельзя вызвать не статический метод по имени класса.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (59, 'Может ли статический метод быть переопределён или перегружен?', 'Нельзя переопределять статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса вместо переопределения. Это явление известно как сокрытие методов (hiding methods) и выполняться всегда будет родительский метод, т.к. выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) <br>Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (61, 'Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 'При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить. <br>Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (62, 'Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 'В сигнатуре(имя + параметры) менять ничего нельзя. <p>Возможно расширение уровня доступа. <br>Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника). <br>Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (64, 'Что означает модификатор final? К чему он может быть применим?', 'Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. <br>Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия. <br>Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. <br>Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно. <br>Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (72, 'Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', '<span class="selected_text color_selected_text">Интерфейс</span> — это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой. <p>- методы интерфейса являются публичными (public) и абстрактными (abstract), static Private Defolte <br>- поля — public static final.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (75, 'Что такое дефолтные методы интерфейсов? Для чего они нужны?', 'В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости. <br>(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) <p>Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (77, 'Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', '1. Статические блоки от первого до последнего предка(от предка до наследника) <br>2. Попарно динамической блок инициализации и конструктор от первого до последнего предка <p>Статические поля класса Parent; <br>Статический блок инициализации класса Parent; <br>Статические поля класса Сhild; <br>Статический блок инициализации класса Child; <br>Нестатические поля класса Parent; <br>Нестатический блок инициализации класса Parent; <br>Конструктор класса Parent; <br>Нестатические поля класса Сhild; <br>Нестатический блок инициализации класса Сhild; <br>Конструктор класса Сhild.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (80, 'Что произойдет, если в блоке инициализации возникнет исключительная ситуация?', 'Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. <p>Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (81, 'Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 'Если возникшее исключение - наследник RuntimeException: <br>-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError. <br>-для нестатических будет проброшено исключение-источник. <p>Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error. <p>Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (85, 'Каким образом реализованы методы hashCode() и equals() в классе Object?', '1 - Реализация метода Object.equals() сводится к проверке на равенство двух ссылок: <p><img class="center" src="images/DBImageInterview/question/85.png" width="270" height="70" alt="image"/> <p>2 - HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым. <br>Реализация метода Object.hashCode() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode. <p>0. Случайно сгенерированное число. <br>1. Функция адреса объекта в памяти. <br>2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)). <br>3. Последовательность.<br>4. Адрес объекта в памяти, приведённый к целочисленному значению. <br>5. Состояние потока, объединённое с xorshift. <p>public native int hashCode(); <p>Ситуация, когда у разных объектов одинаковые хеш-коды называется — <span class="selected_text color_selected_text">коллизией</span>. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (91, 'Правила переопределения метода hashcode()', 'Если хеш-коды разные, то и входные объекты гарантированно разные. <br>Если хеш-коды равны, то входные объекты не всегда равны. <br>При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений. <p>- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись. <br>- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true). <br>- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (122, 'Расскажите про клонирование объектов.', 'В Java, есть 3 способа клонирования объекта: <p>1. С использованием интерфейса Cloneable; <br>Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.  <p>2. С использованием конструктора клонирования объекта; <br>В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта. <p>3. С использованием сериализации. <br>Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (123, 'В чем отличие между поверхностным и глубоким клонированием?', 'Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. <br>Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (126, 'Как создать глубокую копию объекта? (2 способа)', 'Глубокое клонирование требует выполнения следующих правил: <br> - Нет необходимости копировать отдельно примитивные данные; <br> - Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone(); <br> - Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному. <p>1 Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом можем прочитать из него. <br>2 При помощи библиотеки DeepCloneable <br>Глубокое клонирование с этой библиотекой сводится к двум строкам кода: <p><img class="center" src="images/DBImageInterview/question/126.png" width="300" height="45" alt="image"/><p>', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (127, 'Что такое дженерики?', '<span class="selected_text color_selected_text">Дженерики</span> – это параметризованные типы. <br>С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра. <br>Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных. <br>Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List<Object> list вместо List<String> list, например. <br>Появились в версии 1.5', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (128, 'Для чего нужны дженерики?', 'Для строгой типизации и проверки на этапе компиляции. <br>Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (131, 'Расскажите про принцип PECS', '<span class="selected_text color_selected_text">Producer Extends Consumer Super</span> <br>wildcard подстановочный знак: <br> Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает. <br> Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может. <p>Иначе говоря: <br>Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends. <br>Если вы только кладете объекты в коллекцию - это consumer и надо использовать super. <br>Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (135, 'В чем разница между java.util.Collection и java.util.Collections?', '<span class="selected_text color_selected_text">Collection</span>  — это интерфейс, который содержит статический метод, начиная с java8. Интерфейс также может содержать абстрактные методы и методы по умолчанию. <br>Он используется для представления группы отдельных объектов как единого целого. <p><span class="selected_text color_selected_text">Collections</span> - класс, содержит только статические методы. <br>Он определяет несколько служебных методов, которые используются для работы с коллекцией. <br>В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. <br>sort() - сортирует по порядку; <br>binarySearch() - деление напополам для быстрого поиска; <br>reverse() - сортировка по убыванию; <br>copy().', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (143, 'Как поведёт себя коллекция, если вызвать iterator.remove()?', 'Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException. <p>Класс IllegalStateException. Сигналы, что метод был вызван в недопустимое или несоответствующее время. Другими словами среда Java или приложение Java не находятся в соответствующем состоянии для требуемой работы.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (148, 'Что будет, если добавлять элементы в TreeSet по возрастанию?', 'TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. <br>Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering». <p>Реализованный в Comparable метод сравнения называют «natural ordering» — естественной сортировкой. Это потому, что в методе compareTo() ты описываешь наиболее распространенный способ сравнения, который будет использоваться для объектов этого класса в твоей программе. Natural Ordering уже присутствует в Java.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (163, 'Оцените количество памяти на хранение одного примитива типа byte в LinkedList?', 'Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList. <p>Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны. <br>Посчитать на других переменных!', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (149, 'Как устроен HashSet, сложность основных операций.\r\n<br>Big O natation', '<img class="center" src="images/DBImageInterview/question/149.webp" width="500" height="250" alt="image"/><p> Все классы, реализующие интерфейс Set, внутренне поддерживаются реализациями Map. HashSet хранит элементы с помощью HashMap. Значение, которые мы передаем в HashSet, является ключом к объекту HashMap, а в качестве значения используется константа PRESENT. <br>Методы очень быстры. <p>Константное время O(1) - можно прочитать как «сложность порядка 1» (order 1), или «алгоритм выполняется за постоянное/константное время» (constant time). <br>O(1) алгоритмы самые эффективные. <p>Линейное время O(N) скорость линейных алгоритмов, то есть алгоритмов, зависит от количества входных данных. <p>Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время) -  Каждая операция уменьшает количество входных данных вдвое. <br>Сложность O(n*log n) можно представить в виде комбинации O(log n) и O(n). Такую сложность можно получить, если в вашей программе есть один for-цикл, который содержит еще один for-цикл. То есть нестинг циклов, один из которых работает за O(log n), а другой – за O(n).', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (150, 'Как устроен LinkedHashSet, сложность основных операций.', '<img class="center" src="images/DBImageInterview/question/150.webp" width="500" height="250" alt="image"/><p> В его основе лежит LinkedHashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (151, 'Как устроен TreeSet, сложность основных операций.', '<img class="center" src="images/DBImageInterview/question/151.webp" width="500" height="250" alt="image"/><p> Время для базовых операций - Логарифмическое время. <br>Гарантирует порядок элементов - в основе лежит красно-черное дерево, которое умеет само себя балансировать. <br>Не предоставляет каких-либо параметров для настройки производительности. <br>Предоставляет дополнительные методы для упорядоченного списка: first(), last(), headSet(), tailSet(). <p>NavigableSet <br>Интерфейс унаследован от SortedSet и расширяет методы навигации находя ближайшее совпадение по заданному значению. И сродни родительскому интерфейсу в NavigableSet не может быть дубликатов. <p>first() - возврат первого элемента TreeSet, <br>last() - возврат последнего элемента TreeSet, <br>headSet() - используется в качестве установщика ограничений для набора деревьев, чтобы возвращать элементы до предела, определенного в параметре метода, в отсортированном виде, исключая элемент, <br>tailSet() - используется для установки начальной точки для набора деревьев, чтобы вернуть все элементы больше, чем элемент, переданный в качестве параметра, указанного в метод, в отсортированном виде, включая элемент (если элемент упоминается в дереве).', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (153, 'Расскажите про интерфейс List.', 'Контейнеры List хранит элементы в порядке добавления. Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка. Размер по умолчанию 0, вместимость 10. <br>Вложенного класса Node <br>Синхронизация это процесс, который позволяет выполнять все параллельные потоки в программе синхронно.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (154, 'Как устроен ArrayList, сложность основных операций.', '<img class="center" src="images/DBImageInterview/question/154.webp" width="500" height="200" alt="image"/><p> ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. <br>Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize(). <p><span class="selected_text color_selected_text">get(int index)</span> Возвращает элемент в указанной позиции в этом списке. <br><span class="selected_text color_selected_text">contains(Object o)</span> Возвращает true , если этот список содержит указанный элемент. <br><span class="selected_text color_selected_text">add(E e)</span> Добавляет указанный элемент в конец этого списка. <p><span class="selected_text color_selected_text">void add(int index, E element)</span> Вставляет указанный элемент в указанную позицию в этом списке. <br><span class="selected_text color_selected_text">boolean addAll(Collection<? extends E> c)</span> Добавляет все элементы указанной коллекции в конец этого списка в том порядке, в котором они возвращаются итератором указанной коллекции. <br><span class="selected_text color_selected_text">boolean addAll(int index, Collection<? extends E> c)</span> Вставляет все элементы указанной коллекции в этот список, начиная с указанной позиции. <br><span class="selected_text color_selected_text">remove(int index)</span> Удаляет элемент в указанной позиции в этом списке. <br><span class="selected_text color_selected_text">boolean remove(Object o)</span> Удаляет первое вхождение указанного элемента из этого списка, если он присутствует. <br><span class="selected_text color_selected_text">boolean removeAll(Collection<?> c)</span> Удаляет из этого списка все его элементы, содержащиеся в указанной коллекции. <br><span class="selected_text color_selected_text">protected void removeRange(int fromIndex, int toIndex)</span> Удаляет из этого списка все элементы, индекс которых находится между fromIndex, включительно и toIndex, эксклюзивно.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (155, 'Как устроен LinkedList, сложность основных операций?', 'LinkedList - двусвязный список. <br>В LinkedList элементы фактически представляют собой звенья одной цепи. У каждого элемента помимо тех данных, которые он хранит, имеется ссылка на предыдущий и следующий элемент. По этим ссылкам можно переходить от одного элемента к другому. <br>Переменные связаны через методы .next() и .previous(). Добавление элементов - метод add() позволяет указать конкретный индекс для нового элемента. <br>Элементы LinkedList являются единым списком именно благодаря цепочке ссылок. Внутри LinkedList нет массива, как в ArrayList, или чего-то похожего. <br>При удалении элементов remove() Мы просто переопределяем ссылки у двух элементов “по бокам” от удаляемого.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (158, 'Что такое Queue?', '<span class="selected_text color_selected_text">Queue</span> - коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out) порядке. <br><span class="selected_text color_selected_text">PriorityQueue</span> — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering». Работает с приоритетными элементами по возрастанию.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (179, 'Какие встроенные функциональные интерфейсы вы знаете?', 'public interface Consumer<T> - (потребитель) получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает. IntC,LongC,DoubleC,BiC<T,U>. Метод void accept(T t) <p>public interface Supplier<T> - (поставщик) ничего не принимает на вход, но возвращает на выход результат класса T. Метод T get(). BooleanS,IntS,LongS,DoubleS. <p>public interface Predicate<T> - получает на вход экземпляр класса T и возвращает на выходе значение типа boolean (истина или ложь). Метод boolean test(T t). IntP, LongP, DoubleP, BiP<T,U>. <p>public interface Function<T,R> - получает на вход экземпляр класса T и возвращает на выходе экземпляр класса R. Метод R apply(T t).BiF<T,U>. <br>Функции, где на 1 месте или обоих стоят примитивы: Н-р: <br> - DoubleF: double -> T. Принимает double возвращает объект <br> - LongToIntF: long -> int. Принимает long возвращает int <br> - ToIntF: T -> int. Принимает объект возвращает int <p>public interface UnaryOperator<T> extends Function<T,T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T. Частный случай функции. IntU,LongU,DoubleU. <p>public interface BinaryOperator<T, Т> - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T. Частный случай функции. IntB,LongB,DoubleB. <p>Классы для работы с примитивами, т.к дженерики не могут параметризоваться примитивами. <p>ObjDoubleConsumer<T> - операция, которая принимает два аргумента классов T и Double, производит с ними некоторое действие и ничего не возвращает; <br>ObjLongConsumer<T> - операция, которая принимает два аргумента классов T и Long, производит с ними некоторое действие и ничего не возвращает; <br>ObjIntConsumer<T> - операция, которая принимает два аргумента классов T и Integer, производит с ними некоторое действие и ничего не возвращает.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (182, 'Что такое Stream API? Для чего нужны стримы?', 'Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции. <br>Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом. <br>Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (184, 'Какие существуют способы создания стрима?', 'Пустой стрим: Stream.empty() <br>Стрим из List: list.stream() <br>Стрим из Map: map.entrySet().stream() <br>Стрим из массива: Arrays.stream(array) <br>Стрим из указанных элементов: Stream.of("1", "2", "3") <br>-Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов. <br>-Из директории на диске при помощи методов Files.list() и Files.walk(). <br>-Можно получить из строки методом chars(), будет IntStream с символами. <br>-Можно порождать динамически, генерировать при помощи supplier. <br>-Итерированием какой-то функции. <br>-Можно получить диапазон чисел в виде стрима range и rangeClosed. <br>-Конкатенацией других стримов.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (194, 'Какие терминальные методы в стримах вы знаете?', '<span class="selected_text color_selected_text">filter(Predicate)</span> – возвращает элементы которые удовлетворяют предикату <br><span class="selected_text color_selected_text">map(Function)</span> – принимает функцию, которая из каждого элемента стрима получает другой тип <br><span class="selected_text color_selected_text">flatMap(Function)</span> принимает функцию, но вернет обязательно Stream <br><span class="selected_text color_selected_text">distinct()</span> – убирает дубликаты элементов <br><span class="selected_text color_selected_text">sorted()</span> - сортирует стрим по порядку по возрастанию. Если стрим не примитивных типов, а объектов, то можно передать Comparator <br><span class="selected_text color_selected_text">skip(int)</span> – устанавливает сколько пропустить от начала <br><span class="selected_text color_selected_text">limit(int)</span> – устанавливает количество элементов записанных в Stream <br><span class="selected_text color_selected_text">peek(Consumer(sout))</span> – позволяет подсмотреть элементы стрима на любом этапе. После флат или после скип <br><span class="selected_text color_selected_text">takeWhile(Predicate)</span> – оставляет элементы удовлетворяющее предикату (java9) <br><span class="selected_text color_selected_text">dropWhile(Predicate)</span> – удаляет элементы удовлетворяющее предикату  (java9) <br><span class="selected_text color_selected_text">filter(Predicate)</span> – возвращает элементы которые удовлетворяют предикату <br><span class="selected_text color_selected_text">forEach(Consumer(sout))</span> – выводит элементы в соответствующий Consumer <br><span class="selected_text color_selected_text">findFirst()</span> – возвращает первый элемент из стрима возвращает Optional <br><span class="selected_text color_selected_text">findAny()</span> – возвращает  элемент из стрима, который более всего удобно возвращает Optional <br><span class="selected_text color_selected_text">allMach(Predicate)</span> – проверяет удовлетворяют ли все элементы заданному предикату, возвращает boolean <br><span class="selected_text color_selected_text">anyMach(Predicate)</span> – проверяет удовлетворяют ли хотя бы один элемент  заданному предикату, возвращает boolean <br><span class="selected_text color_selected_text">noneMach(Predicate)</span> – проверяет не удовлетворяют ли все элементы заданному предикату, возвращает Boolean <br><span class="title_color text-bold">min()/max</span> – минимальный и максимальный элемент стрима, принимают Comparator(в случае объектов) возвращает Optional. Optional потому что стрим может быть пустой <br><span class="selected_text color_selected_text">count()</span> – возвращает количество оставшихся элементов в стриме, после всех трансформаций <br><span class="selected_text color_selected_text">collect(Collectors)</span> – позволяет собрать стрим в новое хранилище, его тип определяется параметром, который передается в метод (н-р в коллекцию) <br><span class="selected_text color_selected_text">reduce()</span> – вычисляет свертку элементов stream, т.е. результат применения некоторой бинарной операции к каждой паре, пока в стриме не останется один элемент <br><span class="selected_text color_selected_text">sum()</span> - арифметическая сумма элементов стрима. Доступна в стримах примитивах <br><span class="selected_text color_selected_text">average()</span> - возвращает среднее арифметическое всех чисел <br><span class="selected_text color_selected_text">mapToObj()</span> - преобразует числовой стрим обратно в объектный <p>Терминальный метод можно вызвать только один раз. <br>Все оконченные методы возвращают Optional - оболочка ответа (этот специальный тип ввели чтобы не возвращать null) <br><span class="title_color text-bold">map(Function mapper)</span> Применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. map можно применять для изменения типа элементов. <p><span class="title_color text-bold">flatMap(Function<T, Stream<R>> mapper)</span> Один из самых интересных операторов. Работает как map, но с одним отличием — можно преобразовать один элемент в ноль, один или множество других.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (200, 'Какие нововведения появились в java 8?', '1. Полноценная поддержка лямбда-выражений <br>2. Ссылки на методы :: <br>3. Функциональные интерфейсы <br>4. default методы в интерфейсах <br>5. Потоки для работы с коллекциями <br>6. Новое api для работы с датами <br>7. Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle. <br>8. Кодировщик/декодировщик. <br>9. Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\\СomputeIfPresent(), Remove(), GetOrDefault(), Merge() <br>10. Metaspace пришла на замену PermGen', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (207, 'Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?', '<span class="selected_text color_selected_text">putIfAbsent()</span> добавляет пару «ключ-значение», только если ключ отсутствовал: <br><img class="center" src="images/DBImageInterview/question/207.1.png" width="250" height="25" alt="image"/> <br><span class="selected_text color_selected_text">forEach()</span> принимает функцию, которая производит операцию над каждым элементом: <br><img class="center" src="images/DBImageInterview/question/207.2.png" width="350" height="25" alt="image"/> <br><span class="selected_text color_selected_text">compute()</span> создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение): <br><img class="center" src="images/DBImageInterview/question/207.3.png" width="550" height="25" alt="image"/> <br><span class="selected_text color_selected_text">computeIfPresent()</span> если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение): <br><img class="center" src="images/DBImageInterview/question/207.4.png" width="400" height="25" alt="image"/> <br><span class="selected_text color_selected_text">computeIfAbsent()</span> если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ): <br><img class="center" src="images/DBImageInterview/question/207.5.png" width="500" height="25" alt="image"/> <br><span class="selected_text color_selected_text">getOrDefault()</span> в случае отсутствия ключа, возвращает переданное значение по-умолчанию: <br><img class="center" src="images/DBImageInterview/question/207.6.png" width="400" height="25" alt="image"/> <br><span class="selected_text color_selected_text">merge()</span> принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение. <p>- map.remove(key, value) - Если такое ключ-значение есть в map, то удаляем.', 'CORE2') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (213, 'Расскажите про пузырьковую сортировку.', 'Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. <br>Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (216, 'Расскажите про бинарное дерево.', '<span class="selected_text color_selected_text">Бинарное дерево</span> - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная. <br>Поиск в лучшем случае - O(log(n)), худшем - O(n) -  при вырождении в связанный список.', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (218, 'Расскажите про линейный и бинарный поиск.', '<span class="selected_text color_selected_text">Линейный поиск</span> - сложность O(n), так как все элементы проверяются по очереди.  <br><span class="selected_text color_selected_text">Бинарный поиск</span> - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение. <br>1) Берем значение из середины массива и сравниваем с искомым. Индекс середины считается по формуле mid = (high + low) / 2 <br>low - индекс начала левого подмассива, high - индекс конца правого подмассива. <br>2) Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1 <br>3) Если меньше, то правый и low = middle + 1 <br>4) Повторяем, пока mid не становится равен искомому элементу или подмассив не станет пустым. <p><img class="center" src="images/DBImageInterview/question/218.png" width="350" height="300" alt="image"/>', 'ALGORITHMS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (223, 'Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? (Ответ что тред - это класс,  а ранбл интерфейс - считается не полным, нужно рассказать подробно)', '<span class="selected_text color_selected_text">Thread</span> - это класс, некоторая надстройка над физическим потоком. <br><span class="selected_text color_selected_text">Runnable</span> - это интерфейс, представляющий абстракцию над выполняемой задачей. Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком. <br>В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable. Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями. Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable. Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (227, 'Что такое livelock?', '<span class="selected_text color_selected_text">livelock</span> – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock. <br>Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (229, 'Что такое семафор (класс)? Как он реализован в Java?', '<span class="selected_text color_selected_text">Semaphore</span> – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле. <br><span class="selected_text color_selected_text">CountDownLatch</span> - синхронизатор, который позволяет любому количеству потоков ждать пока не завершиться определенное количество операций. В его конструктор нужно передавать количество операций, которые должны завершиться, чтобы потоки продолжили свою работу.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (231, 'Что такое static метод интерфейса?', 'Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс. <br>Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации. <br>Методы класса java.lang.Object нельзя переопределить как статические. <br>Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д. <p>Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.', 'CORE1') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (233, 'Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?', 'Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета (является ли поток демоном). <br>Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRIORITY = 5. <br>Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread. <br>Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (238, 'Чем Runnable отличается от Callable?', 'Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent; <br>Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call(); <br>Метод Runnable.run() не возвращает никакого значения. <br>Callable - это параметризованный функциональный интерфейс. Callable.call() возвращает Object, если он не параметризован, иначе указанный тип. <br>Метод run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (240, 'Что такое deadlock?', '<span class="selected_text color_selected_text">Взаимная блокировка (deadlock)</span> - явление при котором все потоки находятся в режиме ожидания и своё состояние не меняют. Происходит, когда достигаются состояния: <p>Взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени. <br>Удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками. <br>Отсутствия предочистки: операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же. <br>Цикличного ожидания: поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком. <p>Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (247, 'Stream API & ForkJoinPool. Как связаны, что это такое?', 'В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах. <br>По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool. <br>По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер. <br>Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (251, 'Каким образом можно создать поток?', '<span class="selected_text color_selected_text">●</span> Создать потомка класса Thread и переопределить его метод run(); <br><span class="selected_text color_selected_text">●</span> Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run(). <br><span class="selected_text color_selected_text">●</span> Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).', 'MULTITHREADING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (253, 'Назовите основные характеристики шаблонов.', 'Имя - все шаблоны имеют уникальное имя, служащее для их идентификации; <br>Назначение данного шаблона; <br>Задача, которую шаблон позволяет решить; <br>Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден; <br>Участники - сущности, принимающие участие в решении задачи; <br>Следствия от использования шаблона как результат действий, выполняемых в шаблоне; <br>Реализация - возможный вариант реализации шаблона. <p> <span class="selected_text color_selected_text">● Структурные шаблоны (Structural)</span> определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу. <br> <span class="selected_text color_selected_text">● Порождающие (creational)</span> такие шаблоны нужны, чтобы оптимизировать создание того или иного объекта. Порождающие паттерны помогают создавать объекты так, чтобы они эффективно общались с другими, и управлять их работой. <br><span class="selected_text color_selected_text">● Поведенческие шаблоны (Behavioral)</span> определяют взаимодействие между объектами, увеличивая таким образом его гибкость.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (260, 'Расскажите про паттерн Абстрактная фабрика (Abstract Factory).', 'Порождающий паттерн проектирования, который представляет собой интерфейс для создания других классов, не привязываясь к конкретным классам создаваемых объектов. <br>Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее. <br>Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики. <p><span class="selected_text color_selected_text">+</span> : Гарантированно будет создаваться тип одного семейства. <br><span class="selected_text color_selected_text">-</span> : Усложняет код программы из-за введения множества дополнительных классов.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (263, 'Расскажите про паттерн Декоратор (Decorator).', 'Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». <br>Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё. <br>Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу. <br>Адаптер не меняет состояния объекта, а декоратор может менять. <p> <span class="selected_text color_selected_text">+</span> : Большая гибкость, чем у наследования. <br> <span class="selected_text color_selected_text">-</span> : Труднее конфигурировать многократно обёрнутые объекты.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (264, 'Расскажите про паттерн Заместитель (Proxy).', 'Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу. <br>Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. <p> <span class="selected_text color_selected_text">+</span> : Позволяет контролировать сервисный объект незаметно для клиента. <br> <span class="selected_text color_selected_text">-</span> : Увеличивает время отклика от сервиса.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (270, 'Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность).', '<span class="selected_text color_selected_text">Low Coupling</span> - части системы, которые изменяются вместе, должны находиться близко друг к другу. <br><span class="selected_text color_selected_text">High Cohesion</span> - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга. <p>Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (272, 'Что такое Anti-pattern?', '<span class="selected_text color_selected_text">Антипаттерн (anti-pattern)</span> — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным. <p>Примеры: <br>Инверсия абстракции (Abstraction inversion): Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать. <br>Состояние гонки (Race hazard): непредвиденные возможности наступления событий в порядке, отличном от ожидаемого.', 'PATTERNS') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (273, 'Что такое DDL?', 'Какие операции в него входят? Рассказать про них. <span class="selected_text color_selected_text">DDL (Data Definition Language)</span> -  операторы определения данных (Data Definition Language, DDL): <br><span class="selected_text color_selected_text">CREATE</span> создает объект БД (базу, таблицу, представление, пользователя и т. д.), <br><span class="selected_text color_selected_text">ALTER</span> изменяет объект, <br><span class="selected_text color_selected_text">DROP</span> удаляет объект; <br><span class="selected_text color_selected_text">TRUNCATE</span> удаляет таблицу и создает её пустую заново, но если в таблице были foreigh key, то создать таблицу не получится. rollback после TRUNCATE невозможен. <p>SQL (сиквел) является инструментом, предназначенным для организации, управления, выборки и обработки информации, содержащейся в реляционных базах данных.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (278, 'Виды Join’ов?', 'JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. <br>Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. <p>Особенностями операции соединения являются следующее: <br>- в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов; <br>- каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда; <br>- при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно). <p>Какие существуют типы JOIN? <p><span class="selected_text color_selected_text">(INNER) JOIN</span> Результатом объединения таблиц являются записи, общие для левой и правой таблиц. <br>Порядок таблиц для оператора не важен, поскольку оператор является симметричным. <p><span class="selected_text color_selected_text">LEFT (OUTER) JOIN</span> Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. <br>Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (NULL). <br>Порядок таблиц для оператора важен, поскольку оператор не является симметричным. <p><span class="selected_text color_selected_text">RIGHT (OUTER) JOIN</span> расставленными в обратном порядке. <br>Порядок таблиц для оператора важен, поскольку оператор не является симметричным. <p><span class="selected_text color_selected_text">FULL (OUTER) JOIN</span> Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. <br>Порядок таблиц для оператора не важен, поскольку оператор является симметричным. <p><span class="selected_text color_selected_text">CROSS JOIN</span> (декартово произведение) При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. <br>Порядок таблиц для оператора не важен, поскольку оператор является симметричным. <p><img class="center" src="images/DBImageInterview/question/278.png" width="200" height="90" alt="image"/><p> Обратите внимание, в этом запросе нет необходимости указывать какие-либо критерии объединения, поскольку предложение NATURAL JOIN автоматически определяет столбцы, имеющие одинаковые имена в обеих объединяемых таблицах, и помещает их в «скрытое» предложение USING. Если  первичные и внешние ключи имеют одинаковые имена, этот подход может показаться полезным, однако это не так.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (280, 'Что делает UNION?', 'В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY. <br>Разница между UNION и UNION ALL заключается в том, что UNION будет пропускать дубликаты записей, тогда как UNION ALL будет включать дубликаты записей.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (288, 'Расскажите про операторы IN, BETWEEN, LIKE.', '<span class="selected_text color_selected_text">•  IN</span> - определяет набор значений. <br><img class="center" src="images/DBImageInterview/question/288.1.png" width="400" height="25" alt="image"/> <br><span class="selected_text color_selected_text">•  BETWEEN</span> - определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку. <br><img class="center" src="images/DBImageInterview/question/288.2.png" width="400" height="25" alt="image"/> <br><span class="selected_text color_selected_text">•  LIKE</span> - применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь: <br>_ замещает любой одиночный символ. Например, &#39b_t&#39 будет соответствовать словам &#39bat&#39 или &#39bit&#39, но не будет соответствовать &#39brat&#39. <br>% замещает последовательность любого числа символов. Например &#39%p%t&#39 будет соответствовать словам &#39put&#39, &#39posit&#39, или &#39opt&#39, но не &#39spite&#39. <br><img class="center" src="images/DBImageInterview/question/288.3.png" width="350" height="25" alt="image"/>', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (290, 'Какие агрегатные функции вы знаете?', '<span class="selected_text color_selected_text">Агрегатных функции</span> - функции, которые берут группы значений и сводят их к одиночному значению. <br>Несколько агрегатных функций: <br><span class="selected_text color_selected_text">COUNT</span> - производит подсчет записей, удовлетворяющих условию запроса; <br><span class="selected_text color_selected_text">CONCAT</span> - соединяет строки; <br><span class="selected_text color_selected_text">SUM</span> - вычисляет арифметическую сумму всех значений колонки; <br><span class="selected_text color_selected_text">AVG</span> - вычисляет среднее арифметическое всех значений; <br><span class="selected_text color_selected_text">MAX</span> - определяет наибольшее из всех выбранных значений; <br><span class="selected_text color_selected_text">MIN</span> - определяет наименьшее из всех выбранных значений.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (300, 'Что такое представления (VIEW) в SQL? Для чего они нужны?', '<span class="selected_text color_selected_text">View</span> - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. <br>В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице. <br>Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (304, 'Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?', '<span class="selected_text color_selected_text">Нормализация</span> - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс приведения данных в более простую и логичную структуру). <br>Целью является уменьшение потенциальной противоречивости хранимой в базе данных информации. <p><span class="selected_text color_selected_text">Денормализация базы данных</span> — это процесс обратный от нормализации. Эта техника добавляет избыточные данные в таблицу, учитывая частые запросы к базе данных, которые объединяют данные из разных таблиц в одну таблицу. Необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. <p>Каждая нормальная форма включает в себя предыдущую. Типы форм: <br><span class="selected_text color_selected_text">- Первая нормальная форма (1NF)</span> - значения всех полей атомарны (неделимы), нет множества значений в одном поле. <br><span class="selected_text color_selected_text">- Вторая нормальная форма (2NF)</span> - все неключевые поля зависят только от ключа целиком, а не от какой-то его части. <br><span class="selected_text color_selected_text">- Третья нормальная форма (3NF)</span> - все неключевые поля не зависят друг от друга. <br><span class="selected_text color_selected_text">- Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)</span> - когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ. <br><span class="selected_text color_selected_text">- Четвёртая нормальная форма (4NF)</span> - не содержатся независимые группы полей, между которыми существует отношение «многие-ко-многим». <br><span class="selected_text color_selected_text">- Пятая нормальная форма (5NF)</span> - каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения. <br><span class="selected_text color_selected_text">- Доменно-ключевая нормальная форма (DKNF)</span> - каждое наложенное на нее ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение. <br><span class="selected_text color_selected_text">- Шестая нормальная форма (6NF)</span> - удовлетворяет всем нетривиальным зависимостям соединения, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Введена как обобщение пятой нормальной формы для хронологической базы данных.', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (306, 'Шардирование БД', 'При большом количестве данных запросы начинают долго выполняться, и сервер начинает не справляться с нагрузкой. Одно из решений, что с этими данными делать — это масштабирование базы данных. Например, шардинг или репликация. <br>Шардинг бывает вертикальным(партицирование) и горизонтальным. <br>У нас есть большая таблица, например, с пользователями. Партицирование — это когда мы одну большую таблицу разделяем на много маленьких по какому-либо принципу. <br>Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах. <p>Вертикальное масштабирование предполагает наращивание мощностей сервера. <p><span class="selected_text color_selected_text">Репликация</span> - выделяют два типа серверов: master и slave <br><span class="selected_text color_selected_text">Шардинг</span> - это принцип проектирования базы данных, при котором части таблицы хранятся раздельно, на разных физических серверах. <br><span class="selected_text color_selected_text">Партицирование</span> - разбиении данных на части по какому-либо признаку. Например, таблицу можно разбить на две по признаку чётности. <p><img class="center" src="images/DBImageInterview/question/306.1.png" width="300" height="150" alt="image"/><p> Есть таблица news, в которой есть идентификатор, есть категория, в которой эта новость расположена, есть автор новости... <br>Нужно сделать 2 действия над табличкой — это поставить у нашего шарда, например, news_1, то, что она будет наследоваться от news. <br>Наследованная таблица будет иметь все колонки родителя, а также она может иметь свои колонки, которые мы дополнительно туда добавим. Там не будет ограничений, индексов и триггеров от родителя — это важно. <br>2-ое действие — это поставить ограничения. Это будет проверка, что в эту таблицу будут попадать данные только с нужным признаком. <p><img class="center" src="images/DBImageInterview/question/306.2.png" width="230" height="70" alt="image"/><p> Т.е. только записи с category_id=1 будут попадать в эту таблицу. <br>На базовую таблицу надо добавить правило. Когда мы будем работать с таблицей news, вставка на запись с category_id = 1 должна попасть именно в партицию news_1. Правило называем как хотим. <p><img class="center" src="images/DBImageInterview/question/306.3.png" width="400" height="70" alt="image"/>', 'SQL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (315, 'Какие есть важные интерфейсы в Hibernate?', '<span class="selected_text color_selected_text">Session</span> - обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML-операции для экземпляров сущностей. <br><span class="selected_text color_selected_text">SessionFactory</span> - это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения. <br><span class="selected_text color_selected_text">Configuration</span> - объект используется для конфигурирования и начальной загрузки Hibernate. <br><span class="selected_text color_selected_text">Transaction</span> - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API. <br><span class="selected_text color_selected_text">Query</span> - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (317, 'Каким условиям должен удовлетворять класс чтобы являться Entity?', 'Entity это легковесный хранимый объект бизнес логики. Основная программная сущность это entity-класс, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity. <p>1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле. <br>2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности. <br>3) Entity класс должен быть классом верхнего уровня (top-level class). <br>4) Entity класс не может быть enum или интерфейсом. <br>5) Entity класс не может быть финальным классом (final class). <br>6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables). <br>7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс. <br>8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе). <br>9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (322, 'Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?', '<span class="selected_text color_selected_text">Embeddable класс</span> - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity. <br>1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity <br>2. Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded\nEmbeddable-класс может содержать другой встраиваемый класс. Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map&#39ы.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (335, 'Что такое Мемоизация?', '<span class="selected_text color_selected_text">Memoization</span> - вариант кеширования, заключающийся в том, что для функции создаётся таблица результатов. Результат функции, вычисленной при определённых значениях параметров, заносится в эту таблицу. В дальнейшем результат берётся из данной таблицы. <br>Эта техника позволяет за счёт использования дополнительной памяти ускорить работу программы. <br>Можно применить только к функциям, которые являются: <br>1) детерминированными (т.е. при одном и том же наборе параметров функции должны возвращать одинаковое значение). <br>2) без побочных эффектов (т.е. не должны влиять на состояние системы). <br>В Java наиболее подходящей кандидатурой на роль хранилища является интерфейс Map. Сложность операций get, put, contains равна O(1). Что позволяет гарантировать ограничение задержки при выполении мемоизации. <br>Мемоизация реализована в библиотеке ehcache.', 'ADDITIONAL') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (341, 'Какие есть виды связей?', 'Существуют 4 типа связей: \n<br>1. <span class="selected_text color_selected_text">OneToOne</span> - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity. <br>2. <span class="selected_text color_selected_text">OneToMany</span> - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity. <br>3. <span class="selected_text color_selected_text">ManyToOne</span> - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity. <br>4. <span class="selected_text color_selected_text">ManyToMany</span> - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга. <p>Каждую из которых можно разделить ещё на два вида: <br> 1. Bidirectional с использованием mappedBy на стороне, где указывается @OneToMany <br>Bidirectional - ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот). <br>2. Undirectional - ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (356, 'Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?', 'Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа: <br>1.  примитивные типы и их обертки; <br>2.  строки; <br>3.  BigDecimal и BigInteger; <br>4.  java.util.Date и java.sql.Date. <br>Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue. <br>Возможно 4 варианта: <br><span class="selected_text color_selected_text">AUTO(default)</span> - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. <br><span class="selected_text color_selected_text">IDENTITY</span> - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена. <br><span class="selected_text color_selected_text">SEQUENCE</span> - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как гибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение. <br><span class="selected_text color_selected_text">SEQUENCE</span> - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. <br><span class="selected_text color_selected_text">TABLE</span> - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (358, 'Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?', '<span class="selected_text color_selected_text">@OrderBy</span> указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет. Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany. <br>При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов. <br>Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута. <br>Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности: <br>Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу. <br>В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion. <br><span class="selected_text color_selected_text">@OrderColumn</span> создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса. <br>Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице. <br>@OrderBy vs @OrderColumn <br>Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (363, 'Что такое JPQL/HQL и чем он отличается от SQL?', 'Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL. <br>HQL расширяет JPQL и добавляет некоторые специфичные для Hibernate функции. <p>JPQL - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager. <br>SQL - structured query language — «язык структурированных запросов» <p>В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (364, 'Что такое Criteria API и для чего он используется?', 'Начиная с версии 5.2 Hibernate Criteria API объявлен <span class="selected_text color_selected_text">deprecated</span>. Вместо него рекомендуется использовать JPA Criteria API. <br><span class="selected_text color_selected_text">JPA Criteria API</span> - это актуальный API, используемый только для выборки(select) сущностей из БД в более объектно-ориентированном стиле. <br>Основные преимущества JPA Criteria API: <br>❖   ошибки могут быть обнаружены во время компиляции. <br>❖   позволяет динамически формировать запросы на этапе выполнения приложения. <br>Основные недостатки: <br>❖   нет контроля над запросом, сложно отловить ошибку. <br>❖   влияет на производительность, множество классов. <p>Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней. <br>Вот некоторые области применения Criteria API: <br>Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д. <br>Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок. <br>Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection(). <br>Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions). <br>Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (365, 'Расскажите про проблему N+1 Select и путях ее решения.', 'Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса. <p><span class="selected_text color_selected_text">1.  JOIN FETCH</span> <br>И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта. <br>Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).<p><img class="center" src="images/DBImageInterview/question/365.1.png" width="180" height="60" alt="image"/> <p><span class="selected_text color_selected_text">2.  EntityGraph</span> <br>В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph. <p><span class="selected_text color_selected_text">3.   @Fetch(FetchMode.SUBSELECT)</span> <br>Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций: <p><img class="center" src="images/DBImageInterview/question/365.2.png" width="300" height="45" alt="image"/> <p><span class="selected_text color_selected_text">4.   Batch fetching</span> <br>Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации. <p><img class="center" src="images/DBImageInterview/question/365.3.png" width="300" height="45" alt="image"/> <p><span class="selected_text color_selected_text">5.   HibernateSpecificMapping, SqlResultSetMapping</span> <br>Для нативных запросов рекомендуется использовать именно их. <p>1. Лучшим вариантом решения N+1 проблемы для простых запросов (1-3 уровня вложенности связанных объектов) будет join fetch и jpql запрос. Следует придерживаться тактики, когда мы выбираем из jpql и нативного запроса jpql <br>2. Если у нас имеется нативный запрос, и мы не заботимся о слабой связанности кода - то хорошим вариантом будет использование Hibernate Specific Mapping. В противном случае стоит использовать @SqlResultSetMapping \r\n<br>3. В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph <br>4. Если мы знаем примерное количество коллекций, которые будут использоваться в любом месте приложения - можно использовать @BatchSize', 'HIBERNATE') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (367, 'Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?', '<span class="selected_text color_selected_text">Inversion of Control</span> - подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой. <br>Объекты, создаваемые контейнером, называются beans. Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов. <br><span class="selected_text color_selected_text">Dependency Injection</span> — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (384, 'Расскажите про парсирование конфигурации и создание BeanDefinition.', '1. <span class="selected_text color_selected_text">Xml конфигурация</span> — ClassPathXmlApplicationContext(“context.xml”) <br>2. <span class="selected_text color_selected_text">Конфигурация через аннотации с указанием пакета для сканирования</span> — AnnotationConfigApplicationContext(“package.name”) <br>3. <span class="selected_text color_selected_text">Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration</span> -AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig. <br>4. <span class="selected_text color_selected_text">Groovy конфигурация</span> — GenericGroovyApplicationContext(“context.groovy”) <br>Если заглянуть внутрь AnnotationConfigApplicationContext, то можно увидеть два поля.  <br>private final AnnotatedBeanDefinitionReader reader; <br>private final ClassPathBeanDefinitionScanner scanner; <br> ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или её алиаса). Найденные классы парсируются и для них создаются BeanDefinition. Чтобы было запущено сканирование, в конфигурации должен быть указан пакет для сканирования @ComponentScan({"package.name"}). AnnotatedBeanDefinitionReader работает в несколько этапов. <br>1. Первый этап — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true.  <br>2. Второй этап — это регистрация BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassPostProcessor парсирует JavaConfig и создает BeanDefinition. <p>Цель первого этапа — это создание всех BeanDefinition. BeanDefinition — это специальный интерфейс, через который можно получить доступ к метаданным будущего бина. В зависимости от того, какая у вас конфигурация, будет использоваться тот или иной механизм парсирования конфигурации. <br><span class="selected_text color_selected_text">BeanDefinition</span> – это объект, который хранит в себе информацию о бине. Сюда входит: из какого класса бин надо создать, scope, установлена ли ленивая инициализация, нужно ли перед данным бином инициализировать другой, init и destroy методы, зависимости. Все полученные BeanDefinition’ы складываются в ConcurrentHashMap, в которой ключём является имя бина, а объект - сам BeanDefinition. При старте приложения, в IoC контейнер попадут бины, которые имеют scope Singleton (устанавливается по-умолчанию), остальные же создаются, тогда когда они нужны. <p>Парсинг – это процесс сбора данных с последующей их обработкой и анализом.', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (385, 'Расскажите про настройку созданных BeanDefinition.', 'Есть возможность повлиять на бины до их создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В нем один метод. <br>Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных. <br>Разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса — PropertySourcesPlaceholderConfigurer. Он должен быть объявлен как static. <p><img class="center" src="images/DBImageInterview/question/385.png" width="460" height="90" alt="image"/>', 'SPRING') ON CONFLICT DO NOTHING;
INSERT INTO public.question_interview (id, question, answer, topic) VALUES (389, 'Что такое идемпотентный HTTP-метод?', 'В контексте API идемпотентность означает, что многократные запросы обрабатываются так же, как однократные. <br>Это значит, что получив повторный запрос с теми же параметрами, в ответе должен быть результат исходного запроса. <br>Такое поведение помогает избежать нежелательного повторения транзакций. <br>Например, если при проведении платежа возникли проблемы с сетью, и соединение прервалось, вы сможете безопасно повторить нужный запрос неограниченное количество раз. <p>GET-запросы являются по умолчанию идемпотентными, так как не имеют нежелательных последствий. <br>Для идемпотентности POST-запросов используется заголовок "Idempotence-Key" (ключ идемпотентности). <br>Если вы повторяете запрос с теми же данными и тем же ключом, API обрабатывает его как повторный. <br>Если данные в запросе те же, а ключ идемпотентности отличается, запрос выполняется как новый. <br>В заголовке Idempotence-Key можно передавать любое значение, уникальное для этой операции на вашей стороне. <p>Можно использовать ограниченные по времени ключи идемпотентности как дополнительное средство обеспечения безопасности использования вашего REST API.', 'ADDITIONAL') ON CONFLICT DO NOTHING;

INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (1, 'Можем ли мы иметь два main-метода в классе в языке программирования Java?', '', 'Нет', '', '', '', '', 'Да', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (2, 'Вопрос про SQL. <br>Какая команда используется для объединения результатов запроса без удаления дубликатов?', '', 'UNION', 'FULL JOIN', '', '', '', 'UNION ALL', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (3, 'Для создания новой виртуальной таблицы, которая базируется на результатах сделанного ранее SQL запроса, используется команда:', '', 'CREATE VIRTUAL TABLE', 'ALTER VIEW', '', '', '', 'CREATE VIEW', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (4, 'Чем отличается master и origin master в Git?', '', 'Это две разные ветки локального репозитория', 'Ветки origin master не существует', '', '', '', 'Это два разных названия одной ветки master - локальному репозиторию, а origin master - удаленный ', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (5, 'Что означает статус файла untracked в выводе команды git status?', '', 'Что файл был удален из Git', 'Что файл находится вне репозитория Git', 'Что файл добавлен в .gitignore', '', '', 'Что система Git не отслеживает этот файл', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (6, 'Что такое обобщение (Дженерик) в языке программирования Java?', '', 'Позволяет предотвратить ошибки типа ClassNotFoundException', 'Позволяют переопределять "жестко закодированные" типы данных, определенные в методах суперклассов', '', '', '', 'Позволяет создавать параметризированные классы и методы для установления различных типов данных', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (7, 'Сколько систем контроля версий существует?', '', 'Git и XLS', 'Только SVN', 'Только Git', '', '', 'Git, SVN и другие. Но не XLS', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (8, 'Какая структура данных реализуется в HashSet в языке программирования Java?', '', 'Мвссив', 'Дерево', 'Список', '', '', 'Словарь', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (9, 'С помощью какого метода можно отыскать длину строки в языке программирования Java?', '', 'len()', 'size()', '', '', '', 'length()', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (10, 'Какая разница между Mock и Stub?', '', 'Оба используются как заглушки', 'Stub используется для сервисов, а Mock - для методов сервиса', '', '', '', 'Stub - это программируемая заглушка, а Mock подменяет результат вызова и контролирует его', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (11, 'Для чего нужен интерфейс Iterable в языке программирования Java?', '', 'Только для использования коллекции в конструкции forEach', '', '', '', '', 'Для предоставления доступа к итератору и использования конструкции forEach', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (12, 'Какие задачи решает микросервисная архитектура?', '', 'Поддерживаемость и тестируемость', 'Слабое связывание сервисов', 'Независимое развертывание', 'Ориентация на возможности бизнеса', 'Принадлежность к маленькой команде', 'Все перечисленное', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (13, 'Что означает антипаттерн Red Flag Law?', '', 'Блокировние запроса N в цепочке вызовов S, при возникновении ошибок и до ее разрешения в запросе N', 'Такой антипатерн не существует', '', '', '', 'Следование правилам применяемым при разработке монолитной архитектуры', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (14, 'Какие приемы организации хранения данных можно применить при реализации шаблона Database-per-Service?', '', 'Schema-per-service, Database-server-per-service', 'Super-user-per-service, Schema-per-service, Database-server-per-service', 'Privet-tables-per-service, Super-user-per-view, Database-server-per-service', '', '', 'Private-tables-per-service, Schema-per-service, Database-server-per-service', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (16, 'В чем заключается основная задача Realtime Database?', '', 'Данные располагаются в разных регионах для быстрого доступа к ним и повышения устойчивости', 'Realtime Database не требует репликации данных, что сокращает время загрузки сервера для обработки', '', '', '', 'Данные синхронизируются в реальном времени для каждого подключенного клиента', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (17, 'Какая средняя сложность выполнения алгоритмов (согласно Большой О-нотации) для индексов со структурой B-tree в базах данных?', '', 'Space - O(log n), Insert - O(log n), Delete - O(log n), Search - O(log n)', 'Space - O(1), Insert - O(log n), Delete - O(n log n), Search - O(n log n)', '', '', '', 'Space - O(n), Insert - O(log n), Delete - O(log n), Search - O(log n)', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (18, 'Какие из перечисленных ниже составляющие входят в правила переопределения метода equals класса Object в языке программирования Java?', '', 'Асинхронность, Симметричность, Транзитивность, Масштабируемость', 'Консистентность, Асинхронность, Рефлексивность, Транзитивность', '', '', '', 'Рефлексивность, Симметричность, Транзитивность, Консистентность', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (19, 'Можно ли переопределить статический метод?', '', 'Да', '', '', '', '', 'Нет', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (20, 'Какая скорость выполнения операции получения последнего и первого элемента в коллекции LinkedList в языке программирования Java?', '', 'O(log n)', 'O(n)', 'O(n^2)', '', '', 'O(1)', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (21, 'Будет ли доступна аннотация @Override во время выполнения программы?', '', 'Да, будет', 'Произойдет ошибка при попытке получения доступа', '', '', '', 'Нет, эта аннотация отбрасывается компилятором', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (15, 'Какой будет результат выполнения кода?', '<p><img class="center" src="images/DBImageInterview/testing/15.png" width="530" height="250" alt="image"/>', 'x=5 y=9', 'x=4 y=10', 'Ошибка компиляции', '', '', 'x=4 y=9', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (22, 'Что такое Partitioning в базах данных?', '', 'Часто электронное копирование данных из БД на одном компьютере или сервере в БД на другой', '', '', '', '', 'Разделение хранимых объектов баз данных (таблиц, индексов, представлений) на отдельные части', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (23, 'Какой из предложенных способов определения низкой производительности SQL-запроса является верным?', '', 'Выполнить запрос на различных серверах и сравнить результаты', 'Добавить новый индекс для произвольного поля, выполнить запрос и сравнить результаты', '', '', '', 'Выполнить Execution Plan (Query Plan) и проанализировать результаты', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (25, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/25.png" width="500" height="200" alt="image"/>', 'A is equal to NaN', 'Ошибку при выполнении', 'Ошибку компиляции', '', '', 'A is equal to Infinity', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (26, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/26.png" width="550" height="350" alt="image"/>', 'Программа уйдет в бесконечный цикл', 'Hello', 'Hello world', '', '', 'Программа не скомпилируется', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (27, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/27.png" width="500" height="340" alt="image"/>', 'Not equal', '', '', '', '', 'Equal', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (28, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/28.png" width="500" height="300" alt="image"/>', 'Ошибку при выполнении', 'Hello', 'null', '', '', 'Ошибку компиляции', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (29, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/29.png" width="500" height="300" alt="image"/>', '100', '200', 'Ошибку компиляции', '', '', '0', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (30, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/30.png" width="600" height="330" alt="image"/>', 'Main.main() is called', 'Ошибка при компиляции', 'Ошибку компиляции', '', '', 'Main.main(String[] arr) is called', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (32, 'Каким образом внедрить Bean по его имени в качестве аргумента конструктора в Spring Framework? Важно, класс состоит из одного конструктора, Spring-контекст хранит несколько бинов одинакового типа', '', 'Применить аннотацию @Autowired к аргументу конструктора', 'Применить аннотации @autowired и @Qualifier к аргументу конструктора', '', '', '', 'Применить аннотацию @Qualifier к аргументу конструктора', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (33, 'Какое основное преимущество модуля Spring Test?', '', 'Дает доступ к аннотации @Mock и @Stub', 'Предоставляет дополнительный уровень абстракции при роботе с основными фреймворками для тестирования', '', '', '', 'Динамическая генерация mock-объектов и внедрение их в Spring Context', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (34, 'Какой класс необходимо унаследовать для создания собственного события (event) в Spring Framework?', '', 'Event', 'SpringEvent', 'ObjectEvent', '', '', 'ApplicationEvent', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (31, 'Какие из ниже приведенных технологий обычно используются при реализации микросервисной архитектуры?', '', 'Ничего из вышеприведенного', 'Kubernetes', 'Docker', '', '', 'Все вышеприведенное', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (35, 'Что из приведенного нижи является недостатком микросервисной архитектуры?', '', 'Ничего из вышеприведенного', 'Высокие финансовые расходы', 'Микросервисная архитектура требует тщательного мониторинга для эффективной работы', 'Микросервисной архитектурой очень сложно управлять из-за маштабирования', '', 'Все вышеприведенное', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (36, 'Для чего распределенная трассировка (distributed tracing) применяется в микросервисной архитектуре?', '', 'Для изменения поведения микросервиса во время его работы', 'Для передачи управления логированием между хостами по запросу', 'Для обеспечивания правильного восстановления неисправных микросервисов', '', '', 'Для наблюдения за выполнением запросов\ответов между микросервисами и системными вызовами внутри них', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (38, 'Какой класс по-умолчанию реализует интерфейс JpaRepository из стартера Spring Boot Data?', '', 'JpaRepositoryImpl', 'CustomJpaRepository', 'DefaultJpaRepository', 'BaseJpaRepository', 'Ничего из перечисленного', 'SimpleJpaRepository', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (37, 'Для чего используется Spring Boot?', '', 'Для разработки монолитных сервисов', 'Для разработки микросервисов', 'Для разработки распределенных систем', 'Для разработки Web-приложений', '', 'Все вышеперечисленное', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (39, 'Что произойдет если во время старта Spring-приложения в classpath не будет обнаружен Log4j 2.x или SLF4J ?', '', 'Будет выброшено исключение NoBeanDefinitionFound', 'Будет предложено выбрать Log4j 2.x или SLF4J для автоматического добавления в classpath', '', '', '', 'Будет автоматически выбран java.util.logging (JUL)', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (40, 'Перечислите виды classloader предоставляемые платформой Java?', '', 'Static, Reference и Application', 'Bootstrap и Application', 'Static, Bootstrap и Application', '', '', 'Bootstrap, Extension и Application', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (24, 'Какой результат выведет следующая программа?', '<img class="center" src="images/DBImageInterview/testing/24.png" width="550" height="330" alt="image"/>', 'Equal', '', '', '', '', 'Not equal', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (41, 'Возможно ли выполнить валидацию компонент (bean) в Spring Framework?', '', 'Возможно, но исключительно для Web-приложений. Spring Framework поддерживает Jakarta Bean Validation', 'Возможно, за исключением Web-приложений. Spring Framework поддерживает Hibernate Validator', 'Такой возможности нет', '', '', 'Возможно. Spring Framework поддерживает Jakarta Bean Validation и Hibernate Validator', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (42, 'Какой абстрактный способ работы с ресурсами несовместимого типа предоставляет Spring Framework?', '', 'Это невозможно в силу различий операционных систем, где будет выполнятся Spring-приложение', 'Такой возможности нет. Приходится выбирать конкретный тип, чтобы избежать ошибки несовметимости', '', '', '', 'Необходимо использовать абстрактный тип Resource', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (43, 'Перечислите виды classloader предоставляемые платформой Java?', '', 'Static, Reference и Application', 'Bootstrap и Application', 'Static, Bootstrap и Application', '', '', 'Bootstrap, Extension и Application', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (44, 'Объясни что такое Copy Constructor в языке программирования Java?', '', 'Метод для копирования значений переданного в качестве аргумента объекта в текущий объект того же типа', 'Метод для копирования значений переданного в качестве аргумента объекта в текущий объект иного типа', 'Это специальная сущность что необходимо реализовать для работы метода Object#clone()', '', '', 'Это конструктор для инициализации объекта через другой объект того же типа', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (45, 'В чем разница между наследованием и композицией?', '', 'Все ответы верны', 'Наследование - результат проявления полиморфизма, Композиция - ассоциация', 'Наследование - иерархическая связь, Композиция - частный вид наследования', '', '', 'Наследование - иерархическая связь, Композиция - ассоциация', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (46, 'Что такое композиция в рамках ООП?', '', 'Это дизайн класса, при котором один класс наследуется от другого класса', 'Все ответы верны', '', '', '', 'Дизайн класса, в котором один объект состоит из других объектов, и последние не существуют без первого', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (47, 'Что такое композиция в рамках ООП?', '', 'Это парадигма программирования, которая использует классы для определения объектов', 'Парадигма, которая использует  абстрактные данные и методы для представления объектов реального мира', 'Это парадигма программирования, которая фокусируется на объектах, а не на функциях', '', '', 'Все ответы верны', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (48, 'Что произойдет если метод main (entry point) не объявлен как статический?', '', 'Произойдет ошибка на этапе компиляции', 'Программа успешно запустится', '', '', '', 'Программа успешно скомпилируется, но произойдет ошибка в момент ее выполнения', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (49, 'Обязательно ли после блока try должен следовать блок catch в языке программирования Java?', '', 'Нет, необязательно. Блок try может существовать самостоятельно', 'Нет, необязательно. Однако будет ошибка в процессе выполнения программы', 'Да, обязательно', '', '', 'Нет, необязательно. Но тогда должен присутствовать блок finally', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (50, 'Почему в конструкторе НЕ рекомендуется вызывать публичные методы?', '', 'Такая программа не скомпилируется', 'При выполнении программы будет выброшено исключение IllegalStateException', '', '', '', 'Метод может быть переопределен, что приведет к непредвиднному процессу инициализации объекта', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (51, 'Что необходимо для выполнения собранной java-программы?', '', 'Docker', 'Java Compiler', 'Ansible', 'Apache Server', '', 'Java Runtime Environment', 'Java Runtime Environment (также известная как JRE) - минимальная (без компилятора и других средств разработки) реализация виртуальной машины, необходимая для выполнения Jaava-приложений.') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (52, 'Какой будет результат выполнения кода?', '<img class="center" src="images/DBImageInterview/testing/52.png" width="550" height="700" alt="image"/>', '13', '112', '0123', '03', '', '012', '') ON CONFLICT DO NOTHING;
INSERT INTO public.testing_interview (id, question, picture, first_false_answer, second_false_answer, third_false_answer, fourth_false_answer, fifth_false_answer, correct_answer, answer) VALUES (53, 'Какую задачу выполняет CsrfFilter в Spring Security?', '', 'Для кастомной фильтрации реквестов', 'Для кросс серверной авторизации', '', '', '', 'Для идентификации подделки межсайтового запроса', '') ON CONFLICT DO NOTHING;

INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (1, 'Johnny', 'Depp', 'Johnny_Depp@gmail.com', '{bcrypt}$2a$10$tzXyDKmg76XuD6/KsX26TebZQFQ62tNleOtwjMTcOyY/3ThLQo8la', 'ADMIN', '2023-10-08 09:44:41.632801') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (2, 'Al', 'Pacino', 'Al_Pacino@gmail.com', '{bcrypt}$2a$10$dNzZ97RjEFjYNmpozxDAPuCkVg2IdUKNPPZ5tz295sXBJdvStGMay', 'USER', '2023-10-16 19:26:25.096') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (3, 'Robert', 'De Niro', 'Robert_De_Niro@mail.ru', '{bcrypt}$2a$10$ek9cl097lSU6UCCN7nr0UejAyf8tnpaRxjiQx.i8jNu66Z8.jVysO', 'USER', '2023-10-08 09:44:41.632801') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (4, 'Demo', 'User', 'demo@gmail.com', '{bcrypt}$2a$10$f.WsRKXWASU.M.SCpM0NZuXpj2eQD2svJgipbrkn6AueOjy299WKq', 'USER', '2023-10-08 09:44:41.632801') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (5, 'Kevin', 'Spacey', 'Kevin_Spacey@gmail.com', '{bcrypt}$2a$10$TiW5VTbFid7rdZbtVQYZjOMFi/I0bGw/8HbUCkIB7wRuspjU.Zjbi', 'USER', '2023-10-29 17:14:39.114') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (6, 'Denzel', 'Washington', 'Denzel_Washington@gmail.com', '{bcrypt}$2a$10$uw179dIPtQAtMb4APD4CDecMUmqvz/PfTVNgo1.WIKufNnu3..r6W', 'USER', '2023-11-04 12:21:39.556') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (7, 'Russell', 'Crowe', 'Russell_Crowe@gmail.com', '{bcrypt}$2a$10$oS641hHRpc2/0I5dxcN/SeGKFWKueBsZ.oMzIEWvo0uO7m/EWkSZm', 'USER', '2023-10-18 05:35:01.762') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (8, 'Brad', 'Pitt', 'Brad_Pitt@gmail.com', '{bcrypt}$2a$10$MZQLW0k4nvudtm279.oQ3OQUYo5tjFri2mDTClz5GGH0O.6Rle44G', 'USER', '2023-10-19 08:18:14.018') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (9, 'Angelina', 'Jolie', 'Angelina_Jolie@ukr.net', '{bcrypt}$2a$10$yVbXUJr80RLRNIuxJIc4hesPK451v1Sy2dHHTKSiGIPyHolf15wYq', 'USER', '2023-10-19 10:33:40.1') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (10, 'Leonardo', 'DiCaprio', 'Leonardo_DiCaprio0@gmail.com', '{bcrypt}$2a$10$PweVDC51Il4tcz24hplDTeQEf5YTlFBakWPgooY9pKkklLqxxdO4e', 'USER', '2023-10-19 11:51:42.624') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (11, 'Tom', 'Cruise', 'Tom_Cruise@gmail.com', '{bcrypt}$2a$10$ePvSRFbwVQO085LkWtC8TOVI5pwcNge0vx0WFuEh9Z7OFwlueTQG6', 'USER', '2023-10-19 12:09:10.371') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (12, 'John', 'Travolta', 'John_Travolta@gmail.com', '{bcrypt}$2a$10$huUs5CLvBiv63XNSlYTEsehgqaMdJlBec6i9tQdAWrqlbYLodiBMC', 'USER', '2023-10-19 13:00:59.938') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (13, 'Arnold', 'Schwarzenegger', 'Arnold_Schwarzenegger@gmail.com', '{bcrypt}$2a$10$WTAoLyEfKhWi8/2xeK.QAu2W2qaftGrCIDgfE3Wy14/kQyKwyEoeK', 'USER', '2023-10-19 13:24:04.239') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (14, 'Sylvester', 'Stallone', 'Sylvester_Stallone@yahoo.com', '{bcrypt}$2a$10$lfv0CELd1QgZkFG.EM7quevHUDclQFimqLPJbBXUQJsJLwFxm2JGC', 'USER', '2023-10-19 13:35:56.381') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (15, 'Kate', 'Winslet', 'Kate_Winslet@gmail.com', '{bcrypt}$2a$10$n7Tl/Sl0ZCpJGQV4WBlOEuPzsYUa2AGsQgKAY6xBDpJFmJ.fySLSa', 'USER', '2023-10-19 14:21:17.027') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (16, 'Christian', 'Bale', 'Christian_Bale@gmail.com', '{bcrypt}$2a$10$hNVoP.mvC49bGVoMdaSA2OA.Vte/fAS0VNoXXX5iT9qrqjoPDva72', 'USER', '2023-10-19 17:50:44.524') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (17, 'Morgan', 'Freeman', 'Morgan_Freeman@gmail.com', '{bcrypt}$2a$10$vUg5HCkXVoWD5.6fBuPDveDm/oZ.r9Bp7uv9PuD2eAb.vbiqr2I1O', 'USER', '2023-10-19 17:52:58.62') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (18, 'Keanu', 'Reeves', 'Keanu_Reeves@ukr.net', '{bcrypt}$2a$10$8CmNU.hPzxiuT9/4r8nG9eqKfTo2japicjAIJ1prb92FBLvQlN3Zy', 'USER', '2023-10-19 20:51:23.173') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (19, 'Nicolas', 'Cage', 'Nicolas_Cage@gmail.com', '{bcrypt}$2a$10$nf5V8uWRb4LT/NJbcX7bV.cJjcQSC9eOvCJXpQwlA./PpG7AiBYhC', 'USER', '2023-10-19 21:40:26.709') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (20, 'Hugh', 'Jackman', 'Hugh_Jackman@ukr.net', '{bcrypt}$2a$10$xZVCX6Ny8WIepPJ9xN90nelC0u35nKucp7hTNMHgVTGlgG/2dXtLe', 'USER', '2023-10-20 05:51:53.641') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (21, 'Edward', 'Norton', 'Edward_Norton@gmail.com', '{bcrypt}$2a$10$uPsr/Gus4m3fHuJ8UljfzOubElmK25B1Hpiy2VrTPT6BApEQmRqF.', 'USER', '2023-10-21 16:34:28.374') ON CONFLICT DO NOTHING;
INSERT INTO public.users (id, first_name, last_name, email, password, role, registration_date) VALUES (22, 'Bruce', 'Willis', 'Bruce_Willis@gmail.com', '{bcrypt}$2a$10$Fh6J.TPQBH2UoSYzf2ijkeTB4SEi2bbNSKWxbzukJSncAW6nmkFKq', 'USER', '2023-10-26 20:23:15.869') ON CONFLICT DO NOTHING;

INSERT INTO public.statistic (id, date, result, user_id, type, know_answer) VALUES (1, '2023-10-04 17:58:57.223000', 40, 4, 'TESTING', 6) ON CONFLICT DO NOTHING;
INSERT INTO public.statistic (id, date, result, user_id, type, know_answer) VALUES (2, '2023-11-20 17:59:25.368000', 80, 4, 'QUESTIONS', 12) ON CONFLICT DO NOTHING;

SELECT pg_catalog.setval('public.question_id_seq', 432, true);

SELECT pg_catalog.setval('public.statistic_id_seq', 2, true);

SELECT pg_catalog.setval('public.testing_id_seq', 53, true);

SELECT pg_catalog.setval('public.users_id_seq', 22, true);

ALTER TABLE ONLY public.question_interview ADD CONSTRAINT question_interview_pk PRIMARY KEY (id);

ALTER TABLE ONLY public.statistic ADD CONSTRAINT statistic_pk PRIMARY KEY (id);

ALTER TABLE ONLY public.testing_interview ADD CONSTRAINT testing_interview_pk PRIMARY KEY (id);

ALTER TABLE ONLY public.users ADD CONSTRAINT users_pk PRIMARY KEY (id);

CREATE UNIQUE INDEX users__email ON public.users USING btree (email);

ALTER TABLE ONLY public.list_study_questions ADD CONSTRAINT list_study_questions_question_interview_id_fk FOREIGN KEY (question_id) REFERENCES public.question_interview(id);

ALTER TABLE ONLY public.list_study_questions ADD CONSTRAINT list_study_questions_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id);

ALTER TABLE ONLY public.lists_question_interview ADD CONSTRAINT lists_question_interview_question_interview_id_fk FOREIGN KEY (question_id) REFERENCES public.question_interview(id);

ALTER TABLE ONLY public.lists_question_interview ADD CONSTRAINT lists_question_interview_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id);

ALTER TABLE ONLY public.lists_testing_interview ADD CONSTRAINT lists_testing_testing_interview_id_fk FOREIGN KEY (testing_id) REFERENCES public.testing_interview(id);

ALTER TABLE ONLY public.lists_testing_interview ADD CONSTRAINT lists_testing_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id);